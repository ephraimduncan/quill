// @bun
var m4=Object.create;var{getPrototypeOf:u4,defineProperty:e0,getOwnPropertyNames:c4}=Object;var n4=Object.prototype.hasOwnProperty;var G1=(_,$,X)=>{X=_!=null?m4(u4(_)):{};let Z=$||!_||!_.__esModule?e0(X,"default",{value:_,enumerable:!0}):X;for(let Y of c4(_))if(!n4.call(Z,Y))e0(Z,Y,{get:()=>_[Y],enumerable:!0});return Z};var j2=(_,$)=>()=>($||_(($={exports:{}}).exports,$),$.exports);var t4=(_,$)=>{for(var X in $)e0(_,X,{get:$[X],enumerable:!0,configurable:!0,set:(Z)=>$[X]=()=>Z})};var B2=import.meta.require;var A$=j2((D2)=>{var IX=D2&&D2.__createBinding||(Object.create?function(_,$,X,Z){if(Z===void 0)Z=X;var Y=Object.getOwnPropertyDescriptor($,X);if(!Y||("get"in Y?!$.__esModule:Y.writable||Y.configurable))Y={enumerable:!0,get:function(){return $[X]}};Object.defineProperty(_,Z,Y)}:function(_,$,X,Z){if(Z===void 0)Z=X;_[Z]=$[X]}),xX=D2&&D2.__setModuleDefault||(Object.create?function(_,$){Object.defineProperty(_,"default",{enumerable:!0,value:$})}:function(_,$){_.default=$}),H$=D2&&D2.__importStar||function(_){if(_&&_.__esModule)return _;var $={};if(_!=null){for(var X in _)if(X!=="default"&&Object.prototype.hasOwnProperty.call(_,X))IX($,_,X)}return xX($,_),$};Object.defineProperty(D2,"__esModule",{value:!0});D2.load=D2.currentTarget=void 0;var MX=H$(B2("path")),NX=H$(B2("fs"));function EX(){let _=null;switch(process.platform){case"android":switch(process.arch){case"arm":return"android-arm-eabi";case"arm64":return"android-arm64"}_="Android";break;case"win32":switch(process.arch){case"x64":return"win32-x64-msvc";case"arm64":return"win32-arm64-msvc";case"ia32":return"win32-ia32-msvc"}_="Windows";break;case"darwin":switch(process.arch){case"x64":return"darwin-x64";case"arm64":return"darwin-arm64"}_="macOS";break;case"linux":switch(process.arch){case"x64":case"arm64":return wX()?`linux-${process.arch}-gnu`:`linux-${process.arch}-musl`;case"arm":return"linux-arm-gnueabihf"}_="Linux";break;case"freebsd":if(process.arch==="x64")return"freebsd-x64";_="FreeBSD";break}if(_)throw Error(`Neon: unsupported ${_} architecture: ${process.arch}`);throw Error(`Neon: unsupported system: ${process.platform}`)}D2.currentTarget=EX;function wX(){let _=process.report?.getReport();if(typeof _!=="object"||!_||!("header"in _))return!1;let $=_.header;return typeof $==="object"&&!!$&&"glibcVersionRuntime"in $}function PX(_){let $=MX.join(_,"index.node");return NX.existsSync($)?B2($):null}D2.load=PX});var V$=j2((pJ,F$)=>{var U$=()=>process.platform==="linux",x_=null,kX=()=>{if(!x_)x_=U$()&&process.report?process.report.getReport():{};return x_};F$.exports={isLinux:U$,getReport:kX}});var I$=j2((gJ,R$)=>{var K$=B2("fs"),jX=(_)=>K$.readFileSync(_,"utf-8"),BX=(_)=>new Promise(($,X)=>{K$.readFile(_,"utf-8",(Z,Y)=>{if(Z)X(Z);else $(Y)})});R$.exports={LDD_PATH:"/usr/bin/ldd",readFileSync:jX,readFile:BX}});var q$=j2((bJ,h$)=>{var M$=B2("child_process"),{isLinux:A1,getReport:N$}=V$(),{LDD_PATH:E0,readFile:E$,readFileSync:w$}=I$(),E2,w2,p2="",P$=()=>{if(!p2)return new Promise((_)=>{M$.exec("getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true",($,X)=>{p2=$?" ":X,_(p2)})});return p2},k$=()=>{if(!p2)try{p2=M$.execSync("getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true",{encoding:"utf8"})}catch(_){p2=" "}return p2},Q2="glibc",j$=/GLIBC\s(\d+\.\d+)/,r2="musl",TX=Q2.toUpperCase(),QX=r2.toLowerCase(),LX=(_)=>_.includes("libc.musl-")||_.includes("ld-musl-"),B$=()=>{let _=N$();if(_.header&&_.header.glibcVersionRuntime)return Q2;if(Array.isArray(_.sharedObjects)){if(_.sharedObjects.some(LX))return r2}return null},T$=(_)=>{let[$,X]=_.split(/[\r\n]+/);if($&&$.includes(Q2))return Q2;if(X&&X.includes(r2))return r2;return null},Q$=(_)=>{if(_.includes(QX))return r2;if(_.includes(TX))return Q2;return null},vX=async()=>{if(E2!==void 0)return E2;E2=null;try{let _=await E$(E0);E2=Q$(_)}catch(_){}return E2},CX=()=>{if(E2!==void 0)return E2;E2=null;try{let _=w$(E0);E2=Q$(_)}catch(_){}return E2},L$=async()=>{let _=null;if(A1()){if(_=await vX(),!_)_=B$();if(!_){let $=await P$();_=T$($)}}return _},v$=()=>{let _=null;if(A1()){if(_=CX(),!_)_=B$();if(!_){let $=k$();_=T$($)}}return _},fX=async()=>A1()&&await L$()!==Q2,hX=()=>A1()&&v$()!==Q2,qX=async()=>{if(w2!==void 0)return w2;w2=null;try{let $=(await E$(E0)).match(j$);if($)w2=$[1]}catch(_){}return w2},yX=()=>{if(w2!==void 0)return w2;w2=null;try{let $=w$(E0).match(j$);if($)w2=$[1]}catch(_){}return w2},C$=()=>{let _=N$();if(_.header&&_.header.glibcVersionRuntime)return _.header.glibcVersionRuntime;return null},x$=(_)=>_.trim().split(/\s+/)[1],f$=(_)=>{let[$,X,Z]=_.split(/[\r\n]+/);if($&&$.includes(Q2))return x$($);if(X&&Z&&X.includes(r2))return x$(Z);return null},SX=async()=>{let _=null;if(A1()){if(_=await qX(),!_)_=C$();if(!_){let $=await P$();_=f$($)}}return _},pX=()=>{let _=null;if(A1()){if(_=yX(),!_)_=C$();if(!_){let $=k$();_=f$($)}}return _};h$.exports={GLIBC:Q2,MUSL:r2,family:L$,familySync:v$,isNonGlibcLinux:fX,isNonGlibcLinuxSync:hX,version:SX,versionSync:pX}});var S$=j2((dJ,y$)=>{var gX={ALLOW:0,DENY:1};y$.exports=gX});var g$=j2((mJ,p$)=>{var M_={value:"SqliteError",writable:!0,enumerable:!1,configurable:!0};function s2(_,$,X){if(new.target!==s2)return new s2(_,$);if(typeof $!=="string")throw TypeError("Expected second argument to be a string");Error.call(this,_),M_.value=""+_,Object.defineProperty(this,"message",M_),Error.captureStackTrace(this,s2),this.code=$,this.rawCode=X}Object.setPrototypeOf(s2,Error);Object.setPrototypeOf(s2.prototype,Error.prototype);Object.defineProperty(s2.prototype,"name",M_);p$.exports=s2});var o$=j2((uJ,w0)=>{var __dirname="/Users/duncan/dev/reddit-agent/node_modules/libsql",{load:bX,currentTarget:dX}=A$(),{familySync:b$,GLIBC:mX,MUSL:uX}=q$();function cX(){if(process.env.LIBSQL_JS_DEV)return bX(__dirname);let _=dX();if(b$()==mX)switch(_){case"linux-x64-musl":_="linux-x64-gnu";break;case"linux-arm64-musl":_="linux-arm64-gnu";break}if(_==="linux-arm-gnueabihf"&&b$()==uX)_="linux-arm-musleabihf";return B2(`@libsql/${_}`)}var{databaseOpen:nX,databaseOpenWithSync:tX,databaseInTransaction:oX,databaseInterrupt:iX,databaseClose:rX,databaseSyncSync:sX,databaseSyncUntilSync:lX,databaseExecSync:aX,databasePrepareSync:eX,databaseDefaultSafeIntegers:_Z,databaseAuthorizer:$Z,databaseLoadExtension:XZ,databaseMaxWriteReplicationIndex:ZZ,statementRaw:YZ,statementIsReader:GZ,statementGet:d$,statementRun:m$,statementInterrupt:JZ,statementRowsSync:u$,statementColumns:WZ,statementSafeIntegers:zZ,rowsNext:DZ}=cX(),OZ=S$(),c$=g$();function U1(_){if(_.libsqlError)return new c$(_.message,_.code,_.rawCode);return _}class n${constructor(_,$){let X=$?.encryptionCipher??"aes256cbc";if($&&$.syncUrl){var Z="";if($.syncAuth)console.warn("Warning: The `syncAuth` option is deprecated, please use `authToken` option instead."),Z=$.syncAuth;else if($.authToken)Z=$.authToken;let G=$?.encryptionKey??"",J=$?.syncPeriod??0,W=$?.readYourWrites??!0,z=$?.offline??!1,O=$?.remoteEncryptionKey??"";this.db=tX(_,$.syncUrl,Z,X,G,J,W,z,O)}else{let G=$?.authToken??"",J=$?.encryptionKey??"",W=$?.timeout??0,z=$?.remoteEncryptionKey??"";this.db=nX(_,G,X,J,W,z)}this.memory=_===":memory:",this.readonly=!1,this.name="",this.open=!0;let Y=this.db;Object.defineProperties(this,{inTransaction:{get(){return oX(Y)}}})}sync(){return sX.call(this.db)}syncUntil(_){return lX.call(this.db,_)}prepare(_){try{let $=eX.call(this.db,_);return new t$($)}catch($){throw U1($)}}transaction(_){if(typeof _!=="function")throw TypeError("Expected first argument to be a function");let $=this,X=(Y)=>{return(...G)=>{$.exec("BEGIN "+Y);try{let J=_(...G);return $.exec("COMMIT"),J}catch(J){throw $.exec("ROLLBACK"),J}}},Z={default:{value:X("")},deferred:{value:X("DEFERRED")},immediate:{value:X("IMMEDIATE")},exclusive:{value:X("EXCLUSIVE")},database:{value:this,enumerable:!0}};return Object.defineProperties(Z.default.value,Z),Object.defineProperties(Z.deferred.value,Z),Object.defineProperties(Z.immediate.value,Z),Object.defineProperties(Z.exclusive.value,Z),Z.default.value}pragma(_,$){if($==null)$={};if(typeof _!=="string")throw TypeError("Expected first argument to be a string");if(typeof $!=="object")throw TypeError("Expected second argument to be an options object");let X=$.simple,Z=this.prepare(`PRAGMA ${_}`,this,!0);return X?Z.pluck().get():Z.all()}backup(_,$){throw Error("not implemented")}serialize(_){throw Error("not implemented")}function(_,$,X){if($==null)$={};if(typeof $==="function")X=$,$={};if(typeof _!=="string")throw TypeError("Expected first argument to be a string");if(typeof X!=="function")throw TypeError("Expected last argument to be a function");if(typeof $!=="object")throw TypeError("Expected second argument to be an options object");if(!_)throw TypeError("User-defined function name cannot be an empty string");throw Error("not implemented")}aggregate(_,$){if(typeof _!=="string")throw TypeError("Expected first argument to be a string");if(typeof $!=="object"||$===null)throw TypeError("Expected second argument to be an options object");if(!_)throw TypeError("User-defined function name cannot be an empty string");throw Error("not implemented")}table(_,$){if(typeof _!=="string")throw TypeError("Expected first argument to be a string");if(!_)throw TypeError("Virtual table module name cannot be an empty string");throw Error("not implemented")}authorizer(_){$Z.call(this.db,_)}loadExtension(..._){XZ.call(this.db,..._)}maxWriteReplicationIndex(){return ZZ.call(this.db)}exec(_){try{aX.call(this.db,_)}catch($){throw U1($)}}interrupt(){iX.call(this.db)}close(){rX.call(this.db),this.open=!1}defaultSafeIntegers(_){return _Z.call(this.db,_??!0),this}unsafeMode(..._){throw Error("not implemented")}}class t${constructor(_){this.stmt=_,this.pluckMode=!1}raw(_){return YZ.call(this.stmt,_??!0),this}pluck(_){return this.pluckMode=_??!0,this}get reader(){return GZ.call(this.stmt)}run(..._){try{if(_.length==1&&typeof _[0]==="object")return m$.call(this.stmt,_[0]);else return m$.call(this.stmt,_.flat())}catch($){throw U1($)}}get(..._){try{if(_.length==1&&typeof _[0]==="object")return d$.call(this.stmt,_[0]);else return d$.call(this.stmt,_.flat())}catch($){throw U1($)}}iterate(..._){var $=void 0;if(_.length==1&&typeof _[0]==="object")$=u$.call(this.stmt,_[0]);else $=u$.call(this.stmt,_.flat());return{nextRows:Array(100),nextRowIndex:100,next(){try{if(this.nextRowIndex===100)DZ.call($,this.nextRows),this.nextRowIndex=0;let Z=this.nextRows[this.nextRowIndex];if(this.nextRows[this.nextRowIndex]=void 0,!Z)return{done:!0};return this.nextRowIndex++,{value:Z,done:!1}}catch(Z){throw U1(Z)}},[Symbol.iterator](){return this}}}all(..._){try{let $=[];for(let X of this.iterate(..._))if(this.pluckMode)$.push(X[Object.keys(X)[0]]);else $.push(X);return $}catch($){throw U1($)}}interrupt(){JZ.call(this.stmt)}columns(){return WZ.call(this.stmt)}safeIntegers(_){return zZ.call(this.stmt,_??!0),this}}w0.exports=n$;w0.exports.Authorization=OZ;w0.exports.SqliteError=c$});var y0=j2((X1,E8)=>{var J0=B2("node-fetch"),OY=J0.default||J0,q0=function(_,$){if(/^\/\//.test(_))_="https:"+_;return OY.call(this,_,$)};q0.ponyfill=!0;E8.exports=X1=q0;X1.fetch=q0;X1.Headers=J0.Headers;X1.Request=J0.Request;X1.Response=J0.Response;X1.default=q0});var q_=j2((u9,h8)=>{function hY(_){var $=0,X=[];function Z(){if($--,$<_)Y()}function Y(){var z=X.shift();if(W.queue=X.length,z)J(z.fn).then(z.resolve).catch(z.reject)}function G(z){return new Promise(function(O,U){X.push({fn:z,resolve:O,reject:U}),W.queue=X.length})}function J(z){$++;try{return Promise.resolve(z()).then(function(O){return Z(),O},function(O){throw Z(),O})}catch(O){return Z(),Promise.reject(O)}}var W=function(z){if($>=_)return G(z);else return J(z)};return W}function qY(_,$){var X=!1,Z=this;return Promise.all(_.map(function(){var Y=arguments;return Z(function(){if(!X)return $.apply(void 0,Y).catch(function(G){throw X=!0,G})})}))}function f8(_){return _.queue=0,_.map=qY,_}h8.exports=function(_){if(_)return f8(hY(_));else return f8(function($){return $()})}});import{randomUUID as y4}from"crypto";var H=Symbol.for("drizzle:entityKind");function A(_,$){if(!_||typeof _!=="object")return!1;if(_ instanceof $)return!0;if(!Object.prototype.hasOwnProperty.call($,H))throw Error(`Class "${$.name??"<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`);let X=Object.getPrototypeOf(_).constructor;if(X)while(X){if(H in X&&X[H]===$[H])return!0;X=Object.getPrototypeOf(X)}return!1}class T{constructor(_,$){this.table=_,this.config=$,this.name=$.name,this.keyAsName=$.keyAsName,this.notNull=$.notNull,this.default=$.default,this.defaultFn=$.defaultFn,this.onUpdateFn=$.onUpdateFn,this.hasDefault=$.hasDefault,this.primary=$.primaryKey,this.isUnique=$.isUnique,this.uniqueName=$.uniqueName,this.uniqueType=$.uniqueType,this.dataType=$.dataType,this.columnType=$.columnType,this.generated=$.generated,this.generatedIdentity=$.generatedIdentity}static[H]="Column";name;keyAsName;primary;notNull;default;defaultFn;onUpdateFn;hasDefault;isUnique;uniqueName;uniqueType;dataType;columnType;enumValues=void 0;generated=void 0;generatedIdentity=void 0;config;mapFromDriverValue(_){return _}mapToDriverValue(_){return _}shouldDisableInsert(){return this.config.generated!==void 0&&this.config.generated.type!=="byDefault"}}class __{static[H]="ColumnBuilder";config;constructor(_,$,X){this.config={name:_,keyAsName:_==="",notNull:!1,default:void 0,hasDefault:!1,primaryKey:!1,isUnique:!1,uniqueName:void 0,uniqueType:void 0,dataType:$,columnType:X,generated:void 0}}$type(){return this}notNull(){return this.config.notNull=!0,this}default(_){return this.config.default=_,this.config.hasDefault=!0,this}$defaultFn(_){return this.config.defaultFn=_,this.config.hasDefault=!0,this}$default=this.$defaultFn;$onUpdateFn(_){return this.config.onUpdateFn=_,this.config.hasDefault=!0,this}$onUpdate=this.$onUpdateFn;primaryKey(){return this.config.primaryKey=!0,this.config.notNull=!0,this}setName(_){if(this.config.name!=="")return;this.config.name=_}}var Z2=Symbol.for("drizzle:Name");function _6(_,...$){return _(...$)}function $6(_,$){return`${_[Z2]}_${$.join("_")}_unique`}class C1 extends T{constructor(_,$){if(!$.uniqueName)$.uniqueName=$6(_,[$.name]);super(_,$);this.table=_}static[H]="PgColumn"}class o4 extends C1{static[H]="ExtraConfigColumn";getSQLType(){return this.getSQLType()}indexConfig={order:this.config.order??"asc",nulls:this.config.nulls??"last",opClass:this.config.opClass};defaultConfig={order:"asc",nulls:"last",opClass:void 0};asc(){return this.indexConfig.order="asc",this}desc(){return this.indexConfig.order="desc",this}nullsFirst(){return this.indexConfig.nulls="first",this}nullsLast(){return this.indexConfig.nulls="last",this}op(_){return this.indexConfig.opClass=_,this}}class i4 extends C1{static[H]="PgEnumObjectColumn";enum;enumValues=this.config.enum.enumValues;constructor(_,$){super(_,$);this.enum=$.enum}getSQLType(){return this.enum.enumName}}var X6=Symbol.for("drizzle:isPgEnum");function Z6(_){return!!_&&typeof _==="function"&&X6 in _&&_[X6]===!0}class r4 extends C1{static[H]="PgEnumColumn";enum=this.config.enum;enumValues=this.config.enum.enumValues;constructor(_,$){super(_,$);this.enum=$.enum}getSQLType(){return this.enum.enumName}}class f{static[H]="Subquery";constructor(_,$,X,Z=!1,Y=[]){this._={brand:"Subquery",sql:_,selectedFields:$,alias:X,isWith:Z,usedTables:Y}}}class f1 extends f{static[H]="WithSubquery"}var Y6="0.45.1";var $_,X_,G6={startActiveSpan(_,$){if(!$_)return $();if(!X_)X_=$_.trace.getTracer("drizzle-orm",Y6);return _6((X,Z)=>Z.startActiveSpan(_,(Y)=>{try{return $(Y)}catch(G){throw Y.setStatus({code:X.SpanStatusCode.ERROR,message:G instanceof Error?G.message:"Unknown error"}),G}finally{Y.end()}}),$_,X_)}};var h=Symbol.for("drizzle:ViewBaseConfig");var F0=Symbol.for("drizzle:Schema"),V0=Symbol.for("drizzle:Columns"),J6=Symbol.for("drizzle:ExtraConfigColumns"),Z_=Symbol.for("drizzle:OriginalName"),Y_=Symbol.for("drizzle:BaseName"),h1=Symbol.for("drizzle:IsAlias"),W6=Symbol.for("drizzle:ExtraConfigBuilder"),s4=Symbol.for("drizzle:IsDrizzleTable");class F{static[H]="Table";static Symbol={Name:Z2,Schema:F0,OriginalName:Z_,Columns:V0,ExtraConfigColumns:J6,BaseName:Y_,IsAlias:h1,ExtraConfigBuilder:W6};[Z2];[Z_];[F0];[V0];[J6];[Y_];[h1]=!1;[s4]=!0;[W6]=void 0;constructor(_,$,X){this[Z2]=this[Z_]=_,this[F0]=$,this[Y_]=X}}function h2(_){return _[Z2]}function t2(_){return`${_[F0]??"public"}.${_[Z2]}`}function G_(_){return _!==null&&_!==void 0&&typeof _.getSQL==="function"}function l4(_){let $={sql:"",params:[]};for(let X of _)if($.sql+=X.sql,$.params.push(...X.params),X.typings?.length){if(!$.typings)$.typings=[];$.typings.push(...X.typings)}return $}class m{static[H]="StringChunk";value;constructor(_){this.value=Array.isArray(_)?_:[_]}getSQL(){return new K([this])}}class K{constructor(_){this.queryChunks=_;for(let $ of _)if(A($,F)){let X=$[F.Symbol.Schema];this.usedTables.push(X===void 0?$[F.Symbol.Name]:X+"."+$[F.Symbol.Name])}}static[H]="SQL";decoder=D6;shouldInlineParams=!1;usedTables=[];append(_){return this.queryChunks.push(..._.queryChunks),this}toQuery(_){return G6.startActiveSpan("drizzle.buildSQL",($)=>{let X=this.buildQueryFromSourceParams(this.queryChunks,_);return $?.setAttributes({"drizzle.query.text":X.sql,"drizzle.query.params":JSON.stringify(X.params)}),X})}buildQueryFromSourceParams(_,$){let X=Object.assign({},$,{inlineParams:$.inlineParams||this.shouldInlineParams,paramStartIndex:$.paramStartIndex||{value:0}}),{casing:Z,escapeName:Y,escapeParam:G,prepareTyping:J,inlineParams:W,paramStartIndex:z}=X;return l4(_.map((O)=>{if(A(O,m))return{sql:O.value.join(""),params:[]};if(A(O,K0))return{sql:Y(O.value),params:[]};if(O===void 0)return{sql:"",params:[]};if(Array.isArray(O)){let U=[new m("(")];for(let[R,P]of O.entries())if(U.push(P),R<O.length-1)U.push(new m(", "));return U.push(new m(")")),this.buildQueryFromSourceParams(U,X)}if(A(O,K))return this.buildQueryFromSourceParams(O.queryChunks,{...X,inlineParams:W||O.shouldInlineParams});if(A(O,F)){let U=O[F.Symbol.Schema],R=O[F.Symbol.Name];return{sql:U===void 0||O[h1]?Y(R):Y(U)+"."+Y(R),params:[]}}if(A(O,T)){let U=Z.getColumnCasing(O);if($.invokeSource==="indexes")return{sql:Y(U),params:[]};let R=O.table[F.Symbol.Schema];return{sql:O.table[h1]||R===void 0?Y(O.table[F.Symbol.Name])+"."+Y(U):Y(R)+"."+Y(O.table[F.Symbol.Name])+"."+Y(U),params:[]}}if(A(O,W2)){let U=O[h].schema,R=O[h].name;return{sql:U===void 0||O[h].isAlias?Y(R):Y(U)+"."+Y(R),params:[]}}if(A(O,Y2)){if(A(O.value,q2))return{sql:G(z.value++,O),params:[O],typings:["none"]};let U=O.value===null?null:O.encoder.mapToDriverValue(O.value);if(A(U,K))return this.buildQueryFromSourceParams([U],X);if(W)return{sql:this.mapInlineParam(U,X),params:[]};let R=["none"];if(J)R=[J(O.encoder)];return{sql:G(z.value++,U),params:[U],typings:R}}if(A(O,q2))return{sql:G(z.value++,O),params:[O],typings:["none"]};if(A(O,K.Aliased)&&O.fieldAlias!==void 0)return{sql:Y(O.fieldAlias),params:[]};if(A(O,f)){if(O._.isWith)return{sql:Y(O._.alias),params:[]};return this.buildQueryFromSourceParams([new m("("),O._.sql,new m(") "),new K0(O._.alias)],X)}if(Z6(O)){if(O.schema)return{sql:Y(O.schema)+"."+Y(O.enumName),params:[]};return{sql:Y(O.enumName),params:[]}}if(G_(O)){if(O.shouldOmitSQLParens?.())return this.buildQueryFromSourceParams([O.getSQL()],X);return this.buildQueryFromSourceParams([new m("("),O.getSQL(),new m(")")],X)}if(W)return{sql:this.mapInlineParam(O,X),params:[]};return{sql:G(z.value++,O),params:[O],typings:["none"]}}))}mapInlineParam(_,{escapeString:$}){if(_===null)return"null";if(typeof _==="number"||typeof _==="boolean")return _.toString();if(typeof _==="string")return $(_);if(typeof _==="object"){let X=_.toString();if(X==="[object Object]")return $(JSON.stringify(_));return $(X)}throw Error("Unexpected param value: "+_)}getSQL(){return this}as(_){if(_===void 0)return this;return new K.Aliased(this,_)}mapWith(_){return this.decoder=typeof _==="function"?{mapFromDriverValue:_}:_,this}inlineParams(){return this.shouldInlineParams=!0,this}if(_){return _?this:void 0}}class K0{constructor(_){this.value=_}static[H]="Name";brand;getSQL(){return new K([this])}}function z6(_){return typeof _==="object"&&_!==null&&"mapToDriverValue"in _&&typeof _.mapToDriverValue==="function"}var D6={mapFromDriverValue:(_)=>_},O6={mapToDriverValue:(_)=>_},gG={...D6,...O6};class Y2{constructor(_,$=O6){this.value=_,this.encoder=$}static[H]="Param";brand;getSQL(){return new K([this])}}function D(_,...$){let X=[];if($.length>0||_.length>0&&_[0]!=="")X.push(new m(_[0]));for(let[Z,Y]of $.entries())X.push(Y,new m(_[Z+1]));return new K(X)}((_)=>{function $(){return new K([])}_.empty=$;function X(z){return new K(z)}_.fromList=X;function Z(z){return new K([new m(z)])}_.raw=Z;function Y(z,O){let U=[];for(let[R,P]of z.entries()){if(R>0&&O!==void 0)U.push(O);U.push(P)}return new K(U)}_.join=Y;function G(z){return new K0(z)}_.identifier=G;function J(z){return new q2(z)}_.placeholder=J;function W(z,O){return new Y2(z,O)}_.param=W})(D||(D={}));((_)=>{class ${constructor(X,Z){this.sql=X,this.fieldAlias=Z}static[H]="SQL.Aliased";isSelectionField=!1;getSQL(){return this.sql}clone(){return new $(this.sql,this.fieldAlias)}}_.Aliased=$})(K||(K={}));class q2{constructor(_){this.name=_}static[H]="Placeholder";getSQL(){return new K([this])}}function q1(_,$){return _.map((X)=>{if(A(X,q2)){if(!(X.name in $))throw Error(`No value for placeholder "${X.name}" was provided`);return $[X.name]}if(A(X,Y2)&&A(X.value,q2)){if(!(X.value.name in $))throw Error(`No value for placeholder "${X.value.name}" was provided`);return X.encoder.mapToDriverValue($[X.value.name])}return X})}var a4=Symbol.for("drizzle:IsDrizzleView");class W2{static[H]="View";[h];[a4]=!0;constructor({name:_,schema:$,selectedFields:X,query:Z}){this[h]={name:_,originalName:_,schema:$,selectedFields:X,query:Z,isExisting:!Z,isAlias:!1}}getSQL(){return new K([this])}}T.prototype.getSQL=function(){return new K([this])};F.prototype.getSQL=function(){return new K([this])};f.prototype.getSQL=function(){return new K([this])};class J1{constructor(_){this.table=_}static[H]="ColumnAliasProxyHandler";get(_,$){if($==="table")return this.table;return _[$]}}class y1{constructor(_,$){this.alias=_,this.replaceOriginalName=$}static[H]="TableAliasProxyHandler";get(_,$){if($===F.Symbol.IsAlias)return!0;if($===F.Symbol.Name)return this.alias;if(this.replaceOriginalName&&$===F.Symbol.OriginalName)return this.alias;if($===h)return{..._[h],name:this.alias,isAlias:!0};if($===F.Symbol.Columns){let Z=_[F.Symbol.Columns];if(!Z)return Z;let Y={};return Object.keys(Z).map((G)=>{Y[G]=new Proxy(Z[G],new J1(new Proxy(_,this)))}),Y}let X=_[$];if(A(X,T))return new Proxy(X,new J1(new Proxy(_,this)));return X}}function R0(_,$){return new Proxy(_,new y1($,!1))}function x2(_,$){return new Proxy(_,new J1(new Proxy(_.table,new y1($,!1))))}function J_(_,$){return new K.Aliased(S1(_.sql,$),_.fieldAlias)}function S1(_,$){return D.join(_.queryChunks.map((X)=>{if(A(X,T))return x2(X,$);if(A(X,K))return S1(X,$);if(A(X,K.Aliased))return J_(X,$);return X}))}class W1 extends Error{static[H]="DrizzleError";constructor({message:_,cause:$}){super(_);this.name="DrizzleError",this.cause=$}}class T2 extends Error{constructor(_,$,X){super(`Failed query: ${_}
params: ${$}`);if(this.query=_,this.params=$,this.cause=X,Error.captureStackTrace(this,T2),X)this.cause=X}}class W_ extends W1{static[H]="TransactionRollbackError";constructor(){super({message:"Rollback"})}}class H6{static[H]="ConsoleLogWriter";write(_){console.log(_)}}class z_{static[H]="DefaultLogger";writer;constructor(_){this.writer=_?.writer??new H6}logQuery(_,$){let X=$.map((Y)=>{try{return JSON.stringify(Y)}catch{return String(Y)}}),Z=X.length?` -- params: [${X.join(", ")}]`:"";this.writer.write(`Query: ${_}${Z}`)}}class D_{static[H]="NoopLogger";logQuery(){}}class a{static[H]="QueryPromise";[Symbol.toStringTag]="QueryPromise";catch(_){return this.then(void 0,_)}finally(_){return this.then(($)=>{return _?.(),$},($)=>{throw _?.(),$})}then(_,$){return this.execute().then(_,$)}}function O_(_,$,X){let Z={},Y=_.reduce((G,{path:J,field:W},z)=>{let O;if(A(W,T))O=W;else if(A(W,K))O=W.decoder;else if(A(W,f))O=W._.sql.decoder;else O=W.sql.decoder;let U=G;for(let[R,P]of J.entries())if(R<J.length-1){if(!(P in U))U[P]={};U=U[P]}else{let k=$[z],x=U[P]=k===null?null:O.mapFromDriverValue(k);if(X&&A(W,T)&&J.length===2){let M=J[0];if(!(M in Z))Z[M]=x===null?h2(W.table):!1;else if(typeof Z[M]==="string"&&Z[M]!==h2(W.table))Z[M]=!1}}return G},{});if(X&&Object.keys(Z).length>0){for(let[G,J]of Object.entries(Z))if(typeof J==="string"&&!X[J])Y[G]=null}return Y}function z2(_,$){return Object.entries(_).reduce((X,[Z,Y])=>{if(typeof Z!=="string")return X;let G=$?[...$,Z]:[Z];if(A(Y,T)||A(Y,K)||A(Y,K.Aliased)||A(Y,f))X.push({path:G,field:Y});else if(A(Y,F))X.push(...z2(Y[F.Symbol.Columns],G));else X.push(...z2(Y,G));return X},[])}function p1(_,$){let X=Object.keys(_),Z=Object.keys($);if(X.length!==Z.length)return!1;for(let[Y,G]of X.entries())if(G!==Z[Y])return!1;return!0}function I0(_,$){let X=Object.entries($).filter(([,Z])=>Z!==void 0).map(([Z,Y])=>{if(A(Y,K)||A(Y,T))return[Z,Y];else return[Z,new Y2(Y,_[F.Symbol.Columns][Z])]});if(X.length===0)throw Error("No values to set");return Object.fromEntries(X)}function A6(_,$){for(let X of $)for(let Z of Object.getOwnPropertyNames(X.prototype)){if(Z==="constructor")continue;Object.defineProperty(_.prototype,Z,Object.getOwnPropertyDescriptor(X.prototype,Z)||Object.create(null))}}function U6(_){return _[F.Symbol.Columns]}function g1(_){return A(_,f)?_._.alias:A(_,W2)?_[h].name:A(_,K)?void 0:_[F.Symbol.IsAlias]?_[F.Symbol.Name]:_[F.Symbol.BaseName]}function M2(_,$){return{name:typeof _==="string"&&_.length>0?_:"",config:typeof _==="object"?_:$}}function F6(_){if(typeof _!=="object"||_===null)return!1;if(_.constructor.name!=="Object")return!1;if("logger"in _){let $=typeof _.logger;if($!=="boolean"&&($!=="object"||typeof _.logger.logQuery!=="function")&&$!=="undefined")return!1;return!0}if("schema"in _){let $=typeof _.schema;if($!=="object"&&$!=="undefined")return!1;return!0}if("casing"in _){let $=typeof _.casing;if($!=="string"&&$!=="undefined")return!1;return!0}if("mode"in _){if(_.mode!=="default"||_.mode!=="planetscale"||_.mode!==void 0)return!1;return!0}if("connection"in _){let $=typeof _.connection;if($!=="string"&&$!=="object"&&$!=="undefined")return!1;return!0}if("client"in _){let $=typeof _.client;if($!=="object"&&$!=="function"&&$!=="undefined")return!1;return!0}if(Object.keys(_).length===0)return!0;return!1}var H_=typeof TextDecoder>"u"?null:new TextDecoder;var V6=Symbol.for("drizzle:PgInlineForeignKeys"),K6=Symbol.for("drizzle:EnableRLS");class A_ extends F{static[H]="PgTable";static Symbol=Object.assign({},F.Symbol,{InlineForeignKeys:V6,EnableRLS:K6});[V6]=[];[K6]=!1;[F.Symbol.ExtraConfigBuilder]=void 0;[F.Symbol.ExtraConfigColumns]={}}class U_{static[H]="PgPrimaryKeyBuilder";columns;name;constructor(_,$){this.columns=_,this.name=$}build(_){return new R6(_,this.columns,this.name)}}class R6{constructor(_,$,X){this.table=_,this.columns=$,this.name=X}static[H]="PgPrimaryKey";columns;name;getName(){return this.name??`${this.table[A_.Symbol.Name]}_${this.columns.map((_)=>_.name).join("_")}_pk`}}function _2(_,$){if(z6($)&&!G_(_)&&!A(_,Y2)&&!A(_,q2)&&!A(_,T)&&!A(_,F)&&!A(_,W2))return new Y2(_,$);return _}var o2=(_,$)=>{return D`${_} = ${_2($,_)}`},I6=(_,$)=>{return D`${_} <> ${_2($,_)}`};function b1(..._){let $=_.filter((X)=>X!==void 0);if($.length===0)return;if($.length===1)return new K($);return new K([new m("("),D.join($,new m(" and ")),new m(")")])}function x6(..._){let $=_.filter((X)=>X!==void 0);if($.length===0)return;if($.length===1)return new K($);return new K([new m("("),D.join($,new m(" or ")),new m(")")])}function M6(_){return D`not ${_}`}var N6=(_,$)=>{return D`${_} > ${_2($,_)}`},E6=(_,$)=>{return D`${_} >= ${_2($,_)}`},w6=(_,$)=>{return D`${_} < ${_2($,_)}`},P6=(_,$)=>{return D`${_} <= ${_2($,_)}`};function k6(_,$){if(Array.isArray($)){if($.length===0)return D`false`;return D`${_} in ${$.map((X)=>_2(X,_))}`}return D`${_} in ${_2($,_)}`}function j6(_,$){if(Array.isArray($)){if($.length===0)return D`true`;return D`${_} not in ${$.map((X)=>_2(X,_))}`}return D`${_} not in ${_2($,_)}`}function B6(_){return D`${_} is null`}function T6(_){return D`${_} is not null`}function Q6(_){return D`exists ${_}`}function L6(_){return D`not exists ${_}`}function v6(_,$,X){return D`${_} between ${_2($,_)} and ${_2(X,_)}`}function C6(_,$,X){return D`${_} not between ${_2($,_)} and ${_2(X,_)}`}function f6(_,$){return D`${_} like ${$}`}function h6(_,$){return D`${_} not like ${$}`}function q6(_,$){return D`${_} ilike ${$}`}function y6(_,$){return D`${_} not ilike ${$}`}function S6(_){return D`${_} asc`}function p6(_){return D`${_} desc`}class F_{constructor(_,$,X){this.sourceTable=_,this.referencedTable=$,this.relationName=X,this.referencedTableName=$[F.Symbol.Name]}static[H]="Relation";referencedTableName;fieldName}class g6{constructor(_,$){this.table=_,this.config=$}static[H]="Relations"}class y2 extends F_{constructor(_,$,X,Z){super(_,$,X?.relationName);this.config=X,this.isNullable=Z}static[H]="One";withFieldName(_){let $=new y2(this.sourceTable,this.referencedTable,this.config,this.isNullable);return $.fieldName=_,$}}class d1 extends F_{constructor(_,$,X){super(_,$,X?.relationName);this.config=X}static[H]="Many";withFieldName(_){let $=new d1(this.sourceTable,this.referencedTable,this.config);return $.fieldName=_,$}}function b6(){return{and:b1,between:v6,eq:o2,exists:Q6,gt:N6,gte:E6,ilike:q6,inArray:k6,isNull:B6,isNotNull:T6,like:f6,lt:w6,lte:P6,ne:I6,not:M6,notBetween:C6,notExists:L6,notLike:h6,notIlike:y6,notInArray:j6,or:x6,sql:D}}function d6(){return{sql:D,asc:S6,desc:p6}}function m6(_,$){if(Object.keys(_).length===1&&"default"in _&&!A(_.default,F))_=_.default;let X={},Z={},Y={};for(let[G,J]of Object.entries(_))if(A(J,F)){let W=t2(J),z=Z[W];X[W]=G,Y[G]={tsName:G,dbName:J[F.Symbol.Name],schema:J[F.Symbol.Schema],columns:J[F.Symbol.Columns],relations:z?.relations??{},primaryKey:z?.primaryKey??[]};for(let U of Object.values(J[F.Symbol.Columns]))if(U.primary)Y[G].primaryKey.push(U);let O=J[F.Symbol.ExtraConfigBuilder]?.(J[F.Symbol.ExtraConfigColumns]);if(O){for(let U of Object.values(O))if(A(U,U_))Y[G].primaryKey.push(...U.columns)}}else if(A(J,g6)){let W=t2(J.table),z=X[W],O=J.config($(J.table)),U;for(let[R,P]of Object.entries(O))if(z){let k=Y[z];if(k.relations[R]=P,U)k.primaryKey.push(...U)}else{if(!(W in Z))Z[W]={relations:{},primaryKey:U};Z[W].relations[R]=P}}return{tables:Y,tableNamesMap:X}}function e4(_){return function(X,Z){return new y2(_,X,Z,Z?.fields.reduce((Y,G)=>Y&&G.notNull,!0)??!1)}}function _X(_){return function(X,Z){return new d1(_,X,Z)}}function u6(_,$,X){if(A(X,y2)&&X.config)return{fields:X.config.fields,references:X.config.references};let Z=$[t2(X.referencedTable)];if(!Z)throw Error(`Table "${X.referencedTable[F.Symbol.Name]}" not found in schema`);let Y=_[Z];if(!Y)throw Error(`Table "${Z}" not found in schema`);let G=X.sourceTable,J=$[t2(G)];if(!J)throw Error(`Table "${G[F.Symbol.Name]}" not found in schema`);let W=[];for(let z of Object.values(Y.relations))if(X.relationName&&X!==z&&z.relationName===X.relationName||!X.relationName&&z.referencedTable===X.sourceTable)W.push(z);if(W.length>1)throw X.relationName?Error(`There are multiple relations with name "${X.relationName}" in table "${Z}"`):Error(`There are multiple relations between "${Z}" and "${X.sourceTable[F.Symbol.Name]}". Please specify relation name`);if(W[0]&&A(W[0],y2)&&W[0].config)return{fields:W[0].config.references,references:W[0].config.fields};throw Error(`There is not enough information to infer relation "${J}.${X.fieldName}"`)}function c6(_){return{one:e4(_),many:_X(_)}}function x0(_,$,X,Z,Y=(G)=>G){let G={};for(let[J,W]of Z.entries())if(W.isJson){let z=$.relations[W.tsKey],O=X[J],U=typeof O==="string"?JSON.parse(O):O;G[W.tsKey]=A(z,y2)?U&&x0(_,_[W.relationTableTsKey],U,W.selection,Y):U.map((R)=>x0(_,_[W.relationTableTsKey],R,W.selection,Y))}else{let z=Y(X[J]),O=W.field,U;if(A(O,T))U=O;else if(A(O,K))U=O.decoder;else U=O.sql.decoder;G[W.tsKey]=z===null?null:U.mapFromDriverValue(z)}return G}class w extends Error{code;extendedCode;rawCode;constructor(_,$,X,Z,Y){if($!==void 0)_=`${$}: ${_}`;super(_,{cause:Y});this.code=$,this.extendedCode=X,this.rawCode=Z,this.name="LibsqlError"}}class i extends w{statementIndex;constructor(_,$,X,Z,Y,G){super(_,X,Z,Y,G);this.statementIndex=$,this.name="LibsqlBatchError"}}function n6(_){let $=$X.exec(_);if($===null)throw new w(`The URL '${_}' is not in a valid format`,"URL_INVALID");let X=$.groups,Z=X.scheme,Y=X.authority!==void 0?XX(X.authority):void 0,G=i2(X.path),J=X.query!==void 0?YX(X.query):void 0,W=X.fragment!==void 0?i2(X.fragment):void 0;return{scheme:Z,authority:Y,path:G,query:J,fragment:W}}var $X=(()=>{return new RegExp("^(?<scheme>[A-Za-z][A-Za-z.+-]*):(//(?<authority>[^/?#]*))?(?<path>[^?#]*)(\\?(?<query>[^#]*))?(#(?<fragment>.*))?$","su")})();function XX(_){let $=ZX.exec(_);if($===null)throw new w("The authority part of the URL is not in a valid format","URL_INVALID");let X=$.groups,Z=i2(X.host_br??X.host),Y=X.port?parseInt(X.port,10):void 0,G=X.username!==void 0?{username:i2(X.username),password:X.password!==void 0?i2(X.password):void 0}:void 0;return{host:Z,port:Y,userinfo:G}}var ZX=(()=>{return new RegExp("^((?<username>[^:]*)(:(?<password>.*))?@)?((?<host>[^:\\[\\]]*)|(\\[(?<host_br>[^\\[\\]]*)\\]))(:(?<port>[0-9]*))?$","su")})();function YX(_){let $=_.split("&"),X=[];for(let Z of $){if(Z==="")continue;let Y,G,J=Z.indexOf("=");if(J<0)Y=Z,G="";else Y=Z.substring(0,J),G=Z.substring(J+1);X.push({key:i2(Y.replaceAll("+"," ")),value:i2(G.replaceAll("+"," "))})}return{pairs:X}}function i2(_){try{return decodeURIComponent(_)}catch($){if($ instanceof URIError)throw new w(`URL component has invalid percent encoding: ${$}`,"URL_INVALID",void 0,void 0,$);throw $}}function m1(_,$,X){if($===void 0)throw new w(`URL with scheme ${JSON.stringify(_+":")} requires authority (the "//" part)`,"URL_INVALID");let Z=`${_}:`,Y=GX($.host),G=JX($.port),W=`//${WX($.userinfo)}${Y}${G}`,z=X.split("/").map(encodeURIComponent).join("/");if(z!==""&&!z.startsWith("/"))z="/"+z;return new URL(`${Z}${W}${z}`)}function GX(_){return _.includes(":")?`[${encodeURI(_)}]`:encodeURI(_)}function JX(_){return _!==void 0?`:${_}`:""}function WX(_){if(_===void 0)return"";let $=encodeURIComponent(_.username),X=_.password!==void 0?`:${encodeURIComponent(_.password)}`:"";return`${$}${X}@`}var D1=typeof Buffer==="function",t6=typeof TextDecoder==="function"?new TextDecoder:void 0,o6=typeof TextEncoder==="function"?new TextEncoder:void 0;var u1=Array.prototype.slice.call("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="),M0=((_)=>{let $={};return _.forEach((X,Z)=>$[X]=Z),$})(u1),zX=/^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/,r=String.fromCharCode.bind(String),i6=typeof Uint8Array.from==="function"?Uint8Array.from.bind(Uint8Array):(_)=>new Uint8Array(Array.prototype.slice.call(_,0)),l6=(_)=>_.replace(/=/g,"").replace(/[+\/]/g,($)=>$=="+"?"-":"_"),a6=(_)=>_.replace(/[^A-Za-z0-9\+\/]/g,""),e6=(_)=>{let $,X,Z,Y,G="",J=_.length%3;for(let W=0;W<_.length;){if((X=_.charCodeAt(W++))>255||(Z=_.charCodeAt(W++))>255||(Y=_.charCodeAt(W++))>255)throw TypeError("invalid character found");$=X<<16|Z<<8|Y,G+=u1[$>>18&63]+u1[$>>12&63]+u1[$>>6&63]+u1[$&63]}return J?G.slice(0,J-3)+"===".substring(J):G},R_=typeof btoa==="function"?(_)=>btoa(_):D1?(_)=>Buffer.from(_,"binary").toString("base64"):e6,V_=D1?(_)=>Buffer.from(_).toString("base64"):(_)=>{let X=[];for(let Z=0,Y=_.length;Z<Y;Z+=4096)X.push(r.apply(null,_.subarray(Z,Z+4096)));return R_(X.join(""))},N0=(_,$=!1)=>$?l6(V_(_)):V_(_),DX=(_)=>{if(_.length<2){var $=_.charCodeAt(0);return $<128?_:$<2048?r(192|$>>>6)+r(128|$&63):r(224|$>>>12&15)+r(128|$>>>6&63)+r(128|$&63)}else{var $=65536+(_.charCodeAt(0)-55296)*1024+(_.charCodeAt(1)-56320);return r(240|$>>>18&7)+r(128|$>>>12&63)+r(128|$>>>6&63)+r(128|$&63)}},OX=/[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g,_$=(_)=>_.replace(OX,DX),r6=D1?(_)=>Buffer.from(_,"utf8").toString("base64"):o6?(_)=>V_(o6.encode(_)):(_)=>R_(_$(_)),z1=(_,$=!1)=>$?l6(r6(_)):r6(_),s6=(_)=>z1(_,!0),HX=/[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g,AX=(_)=>{switch(_.length){case 4:var $=(7&_.charCodeAt(0))<<18|(63&_.charCodeAt(1))<<12|(63&_.charCodeAt(2))<<6|63&_.charCodeAt(3),X=$-65536;return r((X>>>10)+55296)+r((X&1023)+56320);case 3:return r((15&_.charCodeAt(0))<<12|(63&_.charCodeAt(1))<<6|63&_.charCodeAt(2));default:return r((31&_.charCodeAt(0))<<6|63&_.charCodeAt(1))}},$$=(_)=>_.replace(HX,AX),X$=(_)=>{if(_=_.replace(/\s+/g,""),!zX.test(_))throw TypeError("malformed base64.");_+="==".slice(2-(_.length&3));let $,X,Z,Y=[];for(let G=0;G<_.length;)if($=M0[_.charAt(G++)]<<18|M0[_.charAt(G++)]<<12|(X=M0[_.charAt(G++)])<<6|(Z=M0[_.charAt(G++)]),X===64)Y.push(r($>>16&255));else if(Z===64)Y.push(r($>>16&255,$>>8&255));else Y.push(r($>>16&255,$>>8&255,$&255));return Y.join("")},I_=typeof atob==="function"?(_)=>atob(a6(_)):D1?(_)=>Buffer.from(_,"base64").toString("binary"):X$,Z$=D1?(_)=>i6(Buffer.from(_,"base64")):(_)=>i6(I_(_).split("").map(($)=>$.charCodeAt(0))),Y$=(_)=>Z$(G$(_)),UX=D1?(_)=>Buffer.from(_,"base64").toString("utf8"):t6?(_)=>t6.decode(Z$(_)):(_)=>$$(I_(_)),G$=(_)=>a6(_.replace(/[-_]/g,($)=>$=="-"?"+":"/")),K_=(_)=>UX(G$(_)),FX=(_)=>{if(typeof _!=="string")return!1;let $=_.replace(/\s+/g,"").replace(/={0,2}$/,"");return!/[^\s0-9a-zA-Z\+/]/.test($)||!/[^\s0-9a-zA-Z\-_]/.test($)},J$=(_)=>{return{value:_,enumerable:!1,writable:!0,configurable:!0}},W$=function(){let _=($,X)=>Object.defineProperty(String.prototype,$,J$(X));_("fromBase64",function(){return K_(this)}),_("toBase64",function($){return z1(this,$)}),_("toBase64URI",function(){return z1(this,!0)}),_("toBase64URL",function(){return z1(this,!0)}),_("toUint8Array",function(){return Y$(this)})},z$=function(){let _=($,X)=>Object.defineProperty(Uint8Array.prototype,$,J$(X));_("toBase64",function($){return N0(this,$)}),_("toBase64URI",function(){return N0(this,!0)}),_("toBase64URL",function(){return N0(this,!0)})},VX=()=>{W$(),z$()},O1={version:"3.7.8",VERSION:"3.7.8",atob:I_,atobPolyfill:X$,btoa:R_,btoaPolyfill:e6,fromBase64:K_,toBase64:z1,encode:z1,encodeURI:s6,encodeURL:s6,utob:_$,btou:$$,decode:K_,isValid:FX,fromUint8Array:N0,toUint8Array:Y$,extendString:W$,extendUint8Array:z$,extendBuiltins:VX};var N2="https://github.com/libsql/libsql-client-ts#supported-urls";function S2(_){if(_==="write")return"BEGIN IMMEDIATE";else if(_==="read")return"BEGIN TRANSACTION READONLY";else if(_==="deferred")return"BEGIN DEFERRED";else throw RangeError('Unknown transaction mode, supported values are "write", "read" and "deferred"')}class H1{columns;columnTypes;rows;rowsAffected;lastInsertRowid;constructor(_,$,X,Z,Y){this.columns=_,this.columnTypes=$,this.rows=X,this.rowsAffected=Z,this.lastInsertRowid=Y}toJSON(){return{columns:this.columns,columnTypes:this.columnTypes,rows:this.rows.map(KX),rowsAffected:this.rowsAffected,lastInsertRowid:this.lastInsertRowid!==void 0?""+this.lastInsertRowid:null}}}function KX(_){return Array.prototype.map.call(_,RX)}function RX(_){if(typeof _==="bigint")return""+_;else if(_ instanceof ArrayBuffer)return O1.fromUint8Array(new Uint8Array(_));else return _}var D$=":memory:";function O$(_){return _.scheme==="file"&&(_.path===":memory:"||_.path.startsWith(":memory:?"))}function c1(_,$){if(typeof _!=="object")throw TypeError(`Expected client configuration as object, got ${typeof _}`);let{url:X,authToken:Z,tls:Y,intMode:G,concurrency:J}=_;J=Math.max(0,J||20),G??="number";let W=[];if(X===D$)X="file::memory:";let z=n6(X),O=z.scheme.toLowerCase(),U=O==="file"&&z.path===D$&&z.authority===void 0,R;if(U)R={cache:{values:["shared","private"],update:(M,j)=>W.push(`${M}=${j}`)}};else R={tls:{values:["0","1"],update:(M,j)=>Y=j==="1"},authToken:{update:(M,j)=>Z=j}};for(let{key:M,value:j}of z.query?.pairs??[]){if(!Object.hasOwn(R,M))throw new w(`Unsupported URL query parameter ${JSON.stringify(M)}`,"URL_PARAM_NOT_SUPPORTED");let S=R[M];if(S.values!==void 0&&!S.values.includes(j))throw new w(`Unknown value for the "${M}" query argument: ${JSON.stringify(j)}. Supported values are: [${S.values.map((p)=>'"'+p+'"').join(", ")}]`,"URL_INVALID");if(S.update!==void 0)S?.update(M,j)}let P=W.length===0?"":`?${W.join("&")}`,k=z.path+P,x;if(O==="libsql")if(Y===!1){if(z.authority?.port===void 0)throw new w('A "libsql:" URL with ?tls=0 must specify an explicit port',"URL_INVALID");x=$?"http":"ws"}else x=$?"https":"wss";else x=O;if(x==="http"||x==="ws")Y??=!1;else Y??=!0;if(x!=="http"&&x!=="ws"&&x!=="https"&&x!=="wss"&&x!=="file")throw new w(`The client supports only "libsql:", "wss:", "ws:", "https:", "http:" and "file:" URLs, got ${JSON.stringify(z.scheme+":")}. For more information, please read ${N2}`,"URL_SCHEME_NOT_SUPPORTED");if(G!=="number"&&G!=="bigint"&&G!=="string")throw TypeError(`Invalid value for intMode, expected "number", "bigint" or "string", got ${JSON.stringify(G)}`);if(z.fragment!==void 0)throw new w(`URL fragments are not supported: ${JSON.stringify("#"+z.fragment)}`,"URL_INVALID");if(U)return{scheme:"file",tls:!1,path:k,intMode:G,concurrency:J,syncUrl:_.syncUrl,syncInterval:_.syncInterval,readYourWrites:_.readYourWrites,offline:_.offline,fetch:_.fetch,authToken:void 0,encryptionKey:void 0,remoteEncryptionKey:void 0,authority:void 0};return{scheme:x,tls:Y,authority:z.authority,path:k,authToken:Z,intMode:G,concurrency:J,encryptionKey:_.encryptionKey,remoteEncryptionKey:_.remoteEncryptionKey,syncUrl:_.syncUrl,syncInterval:_.syncInterval,readYourWrites:_.readYourWrites,offline:_.offline,fetch:_.fetch}}var n1=G1(o$(),1);import{Buffer as r$}from"buffer";function s$(_){if(_.scheme!=="file")throw new w(`URL scheme ${JSON.stringify(_.scheme+":")} is not supported by the local sqlite3 client. For more information, please read ${N2}`,"URL_SCHEME_NOT_SUPPORTED");let $=_.authority;if($!==void 0){let J=$.host.toLowerCase();if(J!==""&&J!=="localhost")throw new w(`Invalid host in file URL: ${JSON.stringify($.host)}. A "file:" URL with an absolute path should start with one slash ("file:/absolute/path.db") or with three slashes ("file:///absolute/path.db"). For more information, please read ${N2}`,"URL_INVALID");if($.port!==void 0)throw new w("File URL cannot have a port","URL_INVALID");if($.userinfo!==void 0)throw new w("File URL cannot have username and password","URL_INVALID")}let X=O$(_);if(X&&_.syncUrl)throw new w(`Embedded replica must use file for local db but URI with in-memory mode were provided instead: ${_.path}`,"URL_INVALID");let Z=_.path;if(X)Z=`${_.scheme}:${_.path}`;let Y={authToken:_.authToken,encryptionKey:_.encryptionKey,remoteEncryptionKey:_.remoteEncryptionKey,syncUrl:_.syncUrl,syncPeriod:_.syncInterval,readYourWrites:_.readYourWrites,offline:_.offline},G=new n1.default(Z,Y);return u(G,"SELECT 1 AS checkThatTheDatabaseCanBeOpened",_.intMode),new l$(Z,Y,G,_.intMode)}class l${#_;#$;#X;#Z;closed;protocol;constructor(_,$,X,Z){this.#_=_,this.#$=$,this.#X=X,this.#Z=Z,this.closed=!1,this.protocol="file"}async execute(_,$){let X;if(typeof _==="string")X={sql:_,args:$||[]};else X=_;return this.#Y(),u(this.#G(),X,this.#Z)}async batch(_,$="deferred"){this.#Y();let X=this.#G();try{u(X,S2($),this.#Z);let Z=[];for(let Y=0;Y<_.length;Y++)try{if(!X.inTransaction)throw new i("The transaction has been rolled back",Y,"TRANSACTION_CLOSED");let G=_[Y],J=Array.isArray(G)?{sql:G[0],args:G[1]||[]}:G;Z.push(u(X,J,this.#Z))}catch(G){if(G instanceof i)throw G;if(G instanceof w)throw new i(G.message,Y,G.code,G.extendedCode,G.rawCode,G.cause instanceof Error?G.cause:void 0);throw G}return u(X,"COMMIT",this.#Z),Z}finally{if(X.inTransaction)u(X,"ROLLBACK",this.#Z)}}async migrate(_){this.#Y();let $=this.#G();try{u($,"PRAGMA foreign_keys=off",this.#Z),u($,S2("deferred"),this.#Z);let X=[];for(let Z=0;Z<_.length;Z++)try{if(!$.inTransaction)throw new i("The transaction has been rolled back",Z,"TRANSACTION_CLOSED");X.push(u($,_[Z],this.#Z))}catch(Y){if(Y instanceof i)throw Y;if(Y instanceof w)throw new i(Y.message,Z,Y.code,Y.extendedCode,Y.rawCode,Y.cause instanceof Error?Y.cause:void 0);throw Y}return u($,"COMMIT",this.#Z),X}finally{if($.inTransaction)u($,"ROLLBACK",this.#Z);u($,"PRAGMA foreign_keys=on",this.#Z)}}async transaction(_="write"){let $=this.#G();return u($,S2(_),this.#Z),this.#X=null,new a$($,this.#Z)}async executeMultiple(_){this.#Y();let $=this.#G();try{return e$($,_)}finally{if($.inTransaction)u($,"ROLLBACK",this.#Z)}}async sync(){this.#Y();let _=await this.#G().sync();return{frames_synced:_.frames_synced,frame_no:_.frame_no}}async reconnect(){try{if(!this.closed&&this.#X!==null)this.#X.close()}finally{this.#X=new n1.default(this.#_,this.#$),this.closed=!1}}close(){if(this.closed=!0,this.#X!==null)this.#X.close(),this.#X=null}#Y(){if(this.closed)throw new w("The client is closed","CLIENT_CLOSED")}#G(){if(this.#X===null)this.#X=new n1.default(this.#_,this.#$);return this.#X}}class a${#_;#$;constructor(_,$){this.#_=_,this.#$=$}async execute(_,$){let X;if(typeof _==="string")X={sql:_,args:$||[]};else X=_;return this.#X(),u(this.#_,X,this.#$)}async batch(_){let $=[];for(let X=0;X<_.length;X++)try{this.#X();let Z=_[X],Y=Array.isArray(Z)?{sql:Z[0],args:Z[1]||[]}:Z;$.push(u(this.#_,Y,this.#$))}catch(Z){if(Z instanceof i)throw Z;if(Z instanceof w)throw new i(Z.message,X,Z.code,Z.extendedCode,Z.rawCode,Z.cause instanceof Error?Z.cause:void 0);throw Z}return $}async executeMultiple(_){return this.#X(),e$(this.#_,_)}async rollback(){if(!this.#_.open)return;this.#X(),u(this.#_,"ROLLBACK",this.#$)}async commit(){this.#X(),u(this.#_,"COMMIT",this.#$)}close(){if(this.#_.inTransaction)u(this.#_,"ROLLBACK",this.#$)}get closed(){return!this.#_.inTransaction}#X(){if(this.closed)throw new w("The transaction is closed","TRANSACTION_CLOSED")}}function u(_,$,X){let Z,Y;if(typeof $==="string")Z=$,Y=[];else if(Z=$.sql,Array.isArray($.args))Y=$.args.map((G)=>i$(G,X));else{Y={};for(let G in $.args){let J=G[0]==="@"||G[0]==="$"||G[0]===":"?G.substring(1):G;Y[J]=i$($.args[G],X)}}try{let G=_.prepare(Z);G.safeIntegers(!0);let J=!0;try{G.raw(!0)}catch{J=!1}if(J){let W=Array.from(G.columns().map((P)=>P.name)),z=Array.from(G.columns().map((P)=>P.type??"")),O=G.all(Y).map((P)=>{return HZ(P,W,X)}),U=0,R=void 0;return new H1(W,z,O,0,void 0)}else{let W=G.run(Y),z=W.changes,O=BigInt(W.lastInsertRowid);return new H1([],[],[],z,O)}}catch(G){throw _8(G)}}function HZ(_,$,X){let Z={};Object.defineProperty(Z,"length",{value:_.length});for(let Y=0;Y<_.length;++Y){let G=AZ(_[Y],X);Object.defineProperty(Z,Y,{value:G});let J=$[Y];if(!Object.hasOwn(Z,J))Object.defineProperty(Z,J,{value:G,enumerable:!0,configurable:!0,writable:!0})}return Z}function AZ(_,$){if(typeof _==="bigint")if($==="number"){if(_<UZ||_>FZ)throw RangeError("Received integer which cannot be safely represented as a JavaScript number");return Number(_)}else if($==="bigint")return _;else if($==="string")return""+_;else throw Error("Invalid value for IntMode");else if(_ instanceof r$)return _.buffer;return _}var UZ=-9007199254740991n,FZ=9007199254740991n;function i$(_,$){if(typeof _==="number"){if(!Number.isFinite(_))throw RangeError("Only finite numbers (not Infinity or NaN) can be passed as arguments");return _}else if(typeof _==="bigint"){if(_<VZ||_>KZ)throw RangeError("bigint is too large to be represented as a 64-bit integer and passed as argument");return _}else if(typeof _==="boolean")switch($){case"bigint":return _?1n:0n;case"string":return _?"1":"0";default:return _?1:0}else if(_ instanceof ArrayBuffer)return r$.from(_);else if(_ instanceof Date)return _.valueOf();else if(_===void 0)throw TypeError("undefined cannot be passed as argument to the database");else return _}var VZ=-9223372036854775808n,KZ=9223372036854775807n;function e$(_,$){try{_.exec($)}catch(X){throw _8(X)}}function _8(_){if(_ instanceof n1.default.SqliteError){let $=_.code,X=RZ(_.rawCode);return new w(_.message,X,$,_.rawCode,_)}return _}function RZ(_){if(_===void 0)return"SQLITE_UNKNOWN";let $=_&255;return IZ[$]??`SQLITE_UNKNOWN_${$.toString()}`}var IZ={1:"SQLITE_ERROR",2:"SQLITE_INTERNAL",3:"SQLITE_PERM",4:"SQLITE_ABORT",5:"SQLITE_BUSY",6:"SQLITE_LOCKED",7:"SQLITE_NOMEM",8:"SQLITE_READONLY",9:"SQLITE_INTERRUPT",10:"SQLITE_IOERR",11:"SQLITE_CORRUPT",12:"SQLITE_NOTFOUND",13:"SQLITE_FULL",14:"SQLITE_CANTOPEN",15:"SQLITE_PROTOCOL",16:"SQLITE_EMPTY",17:"SQLITE_SCHEMA",18:"SQLITE_TOOBIG",19:"SQLITE_CONSTRAINT",20:"SQLITE_MISMATCH",21:"SQLITE_MISUSE",22:"SQLITE_NOLFS",23:"SQLITE_AUTH",24:"SQLITE_FORMAT",25:"SQLITE_RANGE",26:"SQLITE_NOTADB",27:"SQLITE_NOTICE",28:"SQLITE_WARNING"};var g2;if(typeof WebSocket<"u")g2=WebSocket;else if(typeof global<"u")g2=global.WebSocket;else if(typeof window<"u")g2=window.WebSocket;else if(typeof self<"u")g2=self.WebSocket;class F1{constructor(){this.intMode="number"}intMode}class L extends Error{constructor(_){super(_);this.name="ClientError"}}class E extends L{constructor(_){super(_);this.name="ProtoError"}}class t1 extends L{code;proto;constructor(_,$){super(_);this.name="ResponseError",this.code=$.code,this.proto=$,this.stack=void 0}}class g extends L{constructor(_,$){if($!==void 0){super(`${_}: ${$}`);this.cause=$}else super(_);this.name="ClosedError"}}class o1 extends L{constructor(_){super(_);this.name="WebSocketUnsupportedError"}}class V1 extends L{constructor(_){super(_);this.name="WebSocketError"}}class l2 extends L{status;constructor(_,$){super(_);this.status=$,this.name="HttpServerError"}}class F2 extends L{constructor(_){super(_);this.name="ProtocolVersionError"}}class l extends L{constructor(_){super(_);this.name="InternalError"}}class P2 extends L{constructor(_){super(_);this.name="MisuseError"}}function $2(_){if(typeof _==="string")return _;throw K1(_,"string")}function G2(_){if(_===null||_===void 0)return;else if(typeof _==="string")return _;throw K1(_,"string or null")}function L2(_){if(typeof _==="number")return _;throw K1(_,"number")}function b2(_){if(typeof _==="boolean")return _;throw K1(_,"boolean")}function i1(_){if(Array.isArray(_))return _;throw K1(_,"array")}function b(_){if(_!==null&&typeof _==="object"&&!Array.isArray(_))return _;throw K1(_,"object")}function V2(_,$){return i1(_).map((X)=>$(b(X)))}function K1(_,$){if(_===void 0)return new E(`Expected ${$}, but the property was missing`);let X=typeof _;if(_===null)X="null";else if(Array.isArray(_))X="array";return new E(`Expected ${$}, received ${X}`)}function a2(_,$){return $(b(_))}class $8{#_;#$;constructor(_){this.#_=_,this.#$=!1}begin(){this.#_.push("{"),this.#$=!0}end(){this.#_.push("}"),this.#$=!1}#X(_){if(this.#$)this.#_.push('"'),this.#$=!1;else this.#_.push(',"');this.#_.push(_),this.#_.push('":')}string(_,$){this.#X(_),this.#_.push(JSON.stringify($))}stringRaw(_,$){this.#X(_),this.#_.push('"'),this.#_.push($),this.#_.push('"')}number(_,$){this.#X(_),this.#_.push(""+$)}boolean(_,$){this.#X(_),this.#_.push($?"true":"false")}object(_,$,X){this.#X(_),this.begin(),X(this,$),this.end()}arrayObjects(_,$,X){this.#X(_),this.#_.push("[");for(let Z=0;Z<$.length;++Z){if(Z!==0)this.#_.push(",");this.begin(),X(this,$[Z]),this.end()}this.#_.push("]")}}function r1(_,$){let X=[],Z=new $8(X);return Z.begin(),$(Z,_),Z.end(),X.join("")}var e2=0,s1=1,l1=2;var X8=5;class Z8{#_;#$;#X;constructor(_){this.#_=_,this.#$=new DataView(_.buffer,_.byteOffset,_.byteLength),this.#X=0}varint(){let _=0;for(let $=0;;$+=7){let X=this.#_[this.#X++];if(_|=(X&127)<<$,!(X&128))break}return _}varintBig(){let _=0n;for(let $=0n;;$+=7n){let X=this.#_[this.#X++];if(_|=BigInt(X&127)<<$,!(X&128))break}return _}bytes(_){let $=new Uint8Array(this.#_.buffer,this.#_.byteOffset+this.#X,_);return this.#X+=_,$}double(){let _=this.#$.getFloat64(this.#X,!0);return this.#X+=8,_}skipVarint(){for(;;)if(!(this.#_[this.#X++]&128))break}skip(_){this.#X+=_}eof(){return this.#X>=this.#_.byteLength}}class Y8{#_;#$;constructor(_){this.#_=_,this.#$=-1}setup(_){this.#$=_}#X(_){if(this.#$!==_)throw new E(`Expected wire type ${_}, got ${this.#$}`);this.#$=-1}bytes(){this.#X(l1);let _=this.#_.varint();return this.#_.bytes(_)}string(){return new TextDecoder().decode(this.bytes())}message(_){return d2(this.bytes(),_)}int32(){return this.#X(e2),this.#_.varint()}uint32(){return this.int32()}bool(){return this.int32()!==0}uint64(){return this.#X(e2),this.#_.varintBig()}sint64(){let _=this.uint64();return _>>1n^-(_&1n)}double(){return this.#X(s1),this.#_.double()}maybeSkip(){if(this.#$<0)return;else if(this.#$===e2)this.#_.skipVarint();else if(this.#$===s1)this.#_.skip(8);else if(this.#$===l1){let _=this.#_.varint();this.#_.skip(_)}else if(this.#$===X8)this.#_.skip(4);else throw new E(`Unexpected wire type ${this.#$}`);this.#$=-1}}function d2(_,$){let X=new Z8(_),Z=new Y8(X),Y=$.default();while(!X.eof()){let G=X.varint(),J=G>>3,W=G&7;Z.setup(W);let z=$[J];if(z!==void 0){let O=z(Z,Y);if(O!==void 0)Y=O}Z.maybeSkip()}return Y}class N_{#_;#$;#X;#Z;constructor(){this.#_=new ArrayBuffer(256),this.#$=new Uint8Array(this.#_),this.#X=new DataView(this.#_),this.#Z=0}#Y(_){if(this.#Z+_<=this.#_.byteLength)return;let $=this.#_.byteLength;while($<this.#Z+_)$*=2;let X=new ArrayBuffer($),Z=new Uint8Array(X),Y=new DataView(X);Z.set(new Uint8Array(this.#_,0,this.#Z)),this.#_=X,this.#$=Z,this.#X=Y}#G(_){this.#Y(5),_=0|_;do{let $=_&127;_>>>=7,$|=_?128:0,this.#$[this.#Z++]=$}while(_)}#J(_){this.#Y(10),_=_&0xffffffffffffffffn;do{let $=Number(_&0x7fn);_>>=7n,$|=_?128:0,this.#$[this.#Z++]=$}while(_)}#W(_,$){this.#G(_<<3|$)}bytes(_,$){this.#W(_,l1),this.#G($.byteLength),this.#Y($.byteLength),this.#$.set($,this.#Z),this.#Z+=$.byteLength}string(_,$){this.bytes(_,new TextEncoder().encode($))}message(_,$,X){let Z=new N_;X(Z,$),this.bytes(_,Z.data())}int32(_,$){this.#W(_,e2),this.#G($)}uint32(_,$){this.int32(_,$)}bool(_,$){this.int32(_,$?1:0)}sint64(_,$){this.#W(_,e2),this.#J($<<1n^$>>63n)}double(_,$){this.#W(_,s1),this.#Y(8),this.#X.setFloat64(this.#Z,$,!0),this.#Z+=8}data(){return new Uint8Array(this.#_,0,this.#Z)}}function a1(_,$){let X=new N_;return $(X,_),X.data()}class m2{#_;#$;constructor(){this.#_=new Set,this.#$=new Set}alloc(){for(let $ of this.#$){if(this.#$.delete($),this.#_.add($),!this.#_.has(this.#_.size-1))this.#$.add(this.#_.size-1);return $}let _=this.#_.size;return this.#_.add(_),_}free(_){if(!this.#_.delete(_))throw new l("Freeing an id that is not allocated");if(this.#$.delete(this.#_.size),_<this.#_.size)this.#$.add(_)}}function Q(_,$){throw new l($)}function R1(_){if(_===null)return null;else if(typeof _==="string")return _;else if(typeof _==="number"){if(!Number.isFinite(_))throw RangeError("Only finite numbers (not Infinity or NaN) can be passed as arguments");return _}else if(typeof _==="bigint"){if(_<MZ||_>NZ)throw RangeError("This bigint value is too large to be represented as a 64-bit integer and passed as argument");return _}else if(typeof _==="boolean")return _?1n:0n;else if(_ instanceof ArrayBuffer)return new Uint8Array(_);else if(_ instanceof Uint8Array)return _;else if(_ instanceof Date)return+_.valueOf();else if(typeof _==="object")return""+_.toString();else throw TypeError("Unsupported type of value")}var MZ=-9223372036854775808n,NZ=9223372036854775807n;function E_(_,$){if(_===null)return null;else if(typeof _==="number")return _;else if(typeof _==="string")return _;else if(typeof _==="bigint")if($==="number"){let X=Number(_);if(!Number.isSafeInteger(X))throw RangeError("Received integer which is too large to be safely represented as a JavaScript number");return X}else if($==="bigint")return _;else if($==="string")return""+_;else throw new P2("Invalid value for IntMode");else if(_ instanceof Uint8Array)return _.slice().buffer;else if(_===void 0)throw new E("Received unrecognized type of Value");else throw Q(_,"Impossible type of Value")}function _1(_){return{affectedRowCount:_.affectedRowCount,lastInsertRowid:_.lastInsertRowid,columnNames:_.cols.map(($)=>$.name),columnDecltypes:_.cols.map(($)=>$.decltype)}}function k0(_,$){let X=_1(_),Z=_.rows.map((Y)=>G8(X.columnNames,Y,$));return{...X,rows:Z}}function j0(_,$){let X=_1(_),Z;if(_.rows.length>0)Z=G8(X.columnNames,_.rows[0],$);return{...X,row:Z}}function B0(_,$){let X=_1(_),Z;if(_.rows.length>0&&X.columnNames.length>0)Z=E_(_.rows[0][0],$);return{...X,value:Z}}function G8(_,$,X){let Z={};Object.defineProperty(Z,"length",{value:$.length});for(let Y=0;Y<$.length;++Y){let G=E_($[Y],X);Object.defineProperty(Z,Y,{value:G});let J=_[Y];if(J!==void 0&&!Object.hasOwn(Z,J))Object.defineProperty(Z,J,{value:G,enumerable:!0,configurable:!0,writable:!0})}return Z}function v2(_){return new t1(_.message,_)}class $1{#_;#$;#X;constructor(_,$){this.#_=_,this.#$=$,this.#X=void 0}_getSqlId(_){if(this.#_!==_)throw new P2("Attempted to use SQL text opened with other object");else if(this.#X!==void 0)throw new g("SQL text is closed",this.#X);return this.#$}close(){this._setClosed(new L("SQL text was manually closed"))}_setClosed(_){if(this.#X===void 0)this.#X=_,this.#_._closeSql(this.#$)}get closed(){return this.#X!==void 0}}function e1(_,$){if($ instanceof $1)return{sqlId:$._getSqlId(_)};else return{sql:""+$}}class u2{#_;#$;constructor(){this.#_=[],this.#$=[]}get length(){return this.#_.length+this.#$.length}push(_){this.#_.push(_)}shift(){if(this.#$.length===0&&this.#_.length>0)this.#$=this.#_.reverse(),this.#_=[];return this.#$.pop()}first(){return this.#$.length!==0?this.#$[this.#$.length-1]:this.#_[0]}}class _0{sql;_args;_namedArgs;constructor(_){this.sql=_,this._args=[],this._namedArgs=new Map}bindIndexes(_){this._args.length=0;for(let $ of _)this._args.push(R1($));return this}bindIndex(_,$){if(_!==(_|0)||_<=0)throw RangeError("Index of a positional argument must be positive integer");while(this._args.length<_)this._args.push(null);return this._args[_-1]=R1($),this}bindName(_,$){return this._namedArgs.set(_,R1($)),this}unbindAll(){return this._args.length=0,this._namedArgs.clear(),this}}function T0(_,$,X){let Z,Y=[],G=[];if($ instanceof _0){Z=$.sql,Y=$._args;for(let[z,O]of $._namedArgs.entries())G.push({name:z,value:O})}else if(Array.isArray($))if(Z=$[0],Array.isArray($[1]))Y=$[1].map((z)=>R1(z));else G=Object.entries($[1]).map(([z,O])=>{return{name:z,value:R1(O)}});else Z=$;let{sql:J,sqlId:W}=e1(_,Z);return{sql:J,sqlId:W,args:Y,namedArgs:G,wantRows:X}}class Q0{_stream;#_;_steps;#$;constructor(_,$){this._stream=_,this.#_=$,this._steps=[],this.#$=!1}step(){return new w_(this)}execute(){if(this.#$)throw new P2("This batch has already been executed");this.#$=!0;let _={steps:this._steps.map(($)=>$.proto)};if(this.#_)return wZ(this._stream,this._steps,_);else return EZ(this._stream,this._steps,_)}}function EZ(_,$,X){return _._batch(X).then((Z)=>{for(let Y=0;Y<$.length;++Y){let G=Z.stepResults.get(Y),J=Z.stepErrors.get(Y);$[Y].callback(G,J)}})}async function wZ(_,$,X){let Z=await _._openCursor(X);try{let Y=0,G=void 0,J=[];for(;;){let W=await Z.next();if(W===void 0)break;if(W.type==="step_begin"){if(W.step<Y||W.step>=$.length)throw new E("Server produced StepBeginEntry for unexpected step");else if(G!==void 0)throw new E("Server produced StepBeginEntry before terminating previous step");for(let z=Y;z<W.step;++z)$[z].callback(void 0,void 0);Y=W.step+1,G=W,J=[]}else if(W.type==="step_end"){if(G===void 0)throw new E("Server produced StepEndEntry but no step is active");let z={cols:G.cols,rows:J,affectedRowCount:W.affectedRowCount,lastInsertRowid:W.lastInsertRowid};$[G.step].callback(z,void 0),G=void 0,J=[]}else if(W.type==="step_error"){if(G===void 0){if(W.step>=$.length)throw new E("Server produced StepErrorEntry for unexpected step");for(let z=Y;z<W.step;++z)$[z].callback(void 0,void 0)}else{if(W.step!==G.step)throw new E("Server produced StepErrorEntry for unexpected step");G=void 0,J=[]}$[W.step].callback(void 0,W.error),Y=W.step+1}else if(W.type==="row"){if(G===void 0)throw new E("Server produced RowEntry but no step is active");J.push(W.row)}else if(W.type==="error")throw v2(W.error);else if(W.type==="none")throw new E("Server produced unrecognized CursorEntry");else throw Q(W,"Impossible CursorEntry")}if(G!==void 0)throw new E("Server closed Cursor before terminating active step");for(let W=Y;W<$.length;++W)$[W].callback(void 0,void 0)}finally{Z.close()}}class w_{_batch;#_;_index;constructor(_){this._batch=_,this.#_=[],this._index=void 0}condition(_){return this.#_.push(_._proto),this}query(_){return this.#$(_,!0,k0)}queryRow(_){return this.#$(_,!0,j0)}queryValue(_){return this.#$(_,!0,B0)}run(_){return this.#$(_,!1,_1)}#$(_,$,X){if(this._index!==void 0)throw new P2("This BatchStep has already been added to the batch");let Z=T0(this._batch._stream._sqlOwner(),_,$),Y;if(this.#_.length===0)Y=void 0;else if(this.#_.length===1)Y=this.#_[0];else Y={type:"and",conds:this.#_.slice()};let G={stmt:Z,condition:Y};return new Promise((J,W)=>{let z=(O,U)=>{if(O!==void 0&&U!==void 0)W(new E("Server returned both result and error"));else if(U!==void 0)W(v2(U));else if(O!==void 0)J(X(O,this._batch._stream.intMode));else J(void 0)};this._index=this._batch._steps.length,this._batch._steps.push({proto:G,callback:z})})}}class q{_batch;_proto;constructor(_,$){this._batch=_,this._proto=$}static ok(_){return new q(_._batch,{type:"ok",step:J8(_)})}static error(_){return new q(_._batch,{type:"error",step:J8(_)})}static not(_){return new q(_._batch,{type:"not",cond:_._proto})}static and(_,$){for(let X of $)W8(_,X);return new q(_,{type:"and",conds:$.map((X)=>X._proto)})}static or(_,$){for(let X of $)W8(_,X);return new q(_,{type:"or",conds:$.map((X)=>X._proto)})}static isAutocommit(_){return _._stream.client()._ensureVersion(3,"BatchCond.isAutocommit()"),new q(_,{type:"is_autocommit"})}}function J8(_){if(_._index===void 0)throw new P2("Cannot add a condition referencing a step that has not been added to the batch");return _._index}function W8(_,$){if($._batch!==_)throw new P2("Cannot mix BatchCond objects for different Batch objects")}function z8(_){return{paramNames:_.params.map(($)=>$.name),columns:_.cols,isExplain:_.isExplain,isReadonly:_.isReadonly}}class I1{constructor(_){this.intMode=_}query(_){return this.#_(_,!0,k0)}queryRow(_){return this.#_(_,!0,j0)}queryValue(_){return this.#_(_,!0,B0)}run(_){return this.#_(_,!1,_1)}#_(_,$,X){let Z=T0(this._sqlOwner(),_,$);return this._execute(Z).then((Y)=>X(Y,this.intMode))}batch(_=!1){return new Q0(this,_)}describe(_){let $=e1(this._sqlOwner(),_);return this._describe($).then(z8)}sequence(_){let $=e1(this._sqlOwner(),_);return this._sequence($)}intMode}class $0{}var PZ=1000,kZ=10;class P_ extends $0{#_;#$;#X;#Z;#Y;#G;#J;constructor(_,$,X){super();this.#_=_,this.#$=$,this.#X=X,this.#Z=new u2,this.#Y=new u2,this.#G=void 0,this.#J=!1}async next(){for(;;){if(this.#G!==void 0)throw new g("Cursor is closed",this.#G);while(!this.#J&&this.#Y.length<kZ)this.#Y.push(this.#W());let _=this.#Z.shift();if(this.#J||_!==void 0)return _;await this.#Y.shift().then(($)=>{if($===void 0)return;for(let X of $.entries)this.#Z.push(X);this.#J||=$.done})}}#W(){return this.#$._sendCursorRequest(this,{type:"fetch_cursor",cursorId:this.#X,maxCount:PZ}).then((_)=>_,(_)=>{this._setClosed(_);return})}_setClosed(_){if(this.#G!==void 0)return;this.#G=_,this.#$._sendCursorRequest(this,{type:"close_cursor",cursorId:this.#X}).catch(()=>{return}),this.#$._cursorClosed(this)}close(){this._setClosed(new L("Cursor was manually closed"))}get closed(){return this.#G!==void 0}}class X0 extends I1{#_;#$;#X;#Z;#Y;#G;static open(_){let $=_._streamIdAlloc.alloc(),X=new X0(_,$),Z=()=>{return},Y=(J)=>X.#O(J),G={type:"open_stream",streamId:$};return _._sendRequest(G,{responseCallback:Z,errorCallback:Y}),X}constructor(_,$){super(_.intMode);this.#_=_,this.#$=$,this.#X=new u2,this.#Z=void 0,this.#Y=!1,this.#G=void 0}client(){return this.#_}_sqlOwner(){return this.#_}_execute(_){return this.#J({type:"execute",streamId:this.#$,stmt:_}).then(($)=>{return $.result})}_batch(_){return this.#J({type:"batch",streamId:this.#$,batch:_}).then(($)=>{return $.result})}_describe(_){return this.#_._ensureVersion(2,"describe()"),this.#J({type:"describe",streamId:this.#$,sql:_.sql,sqlId:_.sqlId}).then(($)=>{return $.result})}_sequence(_){return this.#_._ensureVersion(2,"sequence()"),this.#J({type:"sequence",streamId:this.#$,sql:_.sql,sqlId:_.sqlId}).then(($)=>{return})}getAutocommit(){return this.#_._ensureVersion(3,"getAutocommit()"),this.#J({type:"get_autocommit",streamId:this.#$}).then((_)=>{return _.isAutocommit})}#J(_){return new Promise(($,X)=>{this.#W({type:"request",request:_,responseCallback:$,errorCallback:X})})}_openCursor(_){return this.#_._ensureVersion(3,"cursor"),new Promise(($,X)=>{this.#W({type:"cursor",batch:_,cursorCallback:$,errorCallback:X})})}_sendCursorRequest(_,$){if(_!==this.#Z)throw new l("Cursor not associated with the stream attempted to execute a request");return new Promise((X,Z)=>{if(this.#G!==void 0)Z(new g("Stream is closed",this.#G));else this.#_._sendRequest($,{responseCallback:X,errorCallback:Z})})}_cursorClosed(_){if(_!==this.#Z)throw new l("Cursor was closed, but it was not associated with the stream");this.#Z=void 0,this.#z()}#W(_){if(this.#G!==void 0)_.errorCallback(new g("Stream is closed",this.#G));else if(this.#Y)_.errorCallback(new g("Stream is closing",void 0));else this.#X.push(_),this.#z()}#z(){for(;;){let _=this.#X.first();if(_===void 0&&this.#Z===void 0&&this.#Y){this.#O(new L("Stream was gracefully closed"));break}else if(_?.type==="request"&&this.#Z===void 0){let{request:$,responseCallback:X,errorCallback:Z}=_;this.#X.shift(),this.#_._sendRequest($,{responseCallback:X,errorCallback:Z})}else if(_?.type==="cursor"&&this.#Z===void 0){let{batch:$,cursorCallback:X}=_;this.#X.shift();let Z=this.#_._cursorIdAlloc.alloc(),Y=new P_(this.#_,this,Z),G={type:"open_cursor",streamId:this.#$,cursorId:Z,batch:$},J=()=>{return},W=(z)=>Y._setClosed(z);this.#_._sendRequest(G,{responseCallback:J,errorCallback:W}),this.#Z=Y,X(Y)}else break}}#O(_){if(this.#G!==void 0)return;if(this.#G=_,this.#Z!==void 0)this.#Z._setClosed(_);for(;;){let Y=this.#X.shift();if(Y!==void 0)Y.errorCallback(_);else break}let $={type:"close_stream",streamId:this.#$},X=()=>this.#_._streamIdAlloc.free(this.#$),Z=()=>{return};this.#_._sendRequest($,{responseCallback:X,errorCallback:Z})}close(){this.#O(new L("Stream was manually closed"))}closeGracefully(){this.#Y=!0,this.#z()}get closed(){return this.#G!==void 0||this.#Y}}function Z0(_,$){if($.sql!==void 0)_.string("sql",$.sql);if($.sqlId!==void 0)_.number("sql_id",$.sqlId);_.arrayObjects("args",$.args,D8),_.arrayObjects("named_args",$.namedArgs,jZ),_.boolean("want_rows",$.wantRows)}function jZ(_,$){_.string("name",$.name),_.object("value",$.value,D8)}function x1(_,$){_.arrayObjects("steps",$.steps,BZ)}function BZ(_,$){if($.condition!==void 0)_.object("condition",$.condition,k_);_.object("stmt",$.stmt,Z0)}function k_(_,$){if(_.stringRaw("type",$.type),$.type==="ok"||$.type==="error")_.number("step",$.step);else if($.type==="not")_.object("cond",$.cond,k_);else if($.type==="and"||$.type==="or")_.arrayObjects("conds",$.conds,k_);else if($.type==="is_autocommit");else throw Q($,"Impossible type of BatchCond")}function D8(_,$){if($===null)_.stringRaw("type","null");else if(typeof $==="bigint")_.stringRaw("type","integer"),_.stringRaw("value",""+$);else if(typeof $==="number")_.stringRaw("type","float"),_.number("value",$);else if(typeof $==="string")_.stringRaw("type","text"),_.string("value",$);else if($ instanceof Uint8Array)_.stringRaw("type","blob"),_.stringRaw("base64",O1.fromUint8Array($));else if($===void 0);else throw Q($,"Impossible type of Value")}function O8(_,$){if(_.stringRaw("type",$.type),$.type==="hello"){if($.jwt!==void 0)_.string("jwt",$.jwt)}else if($.type==="request")_.number("request_id",$.requestId),_.object("request",$.request,TZ);else throw Q($,"Impossible type of ClientMsg")}function TZ(_,$){if(_.stringRaw("type",$.type),$.type==="open_stream")_.number("stream_id",$.streamId);else if($.type==="close_stream")_.number("stream_id",$.streamId);else if($.type==="execute")_.number("stream_id",$.streamId),_.object("stmt",$.stmt,Z0);else if($.type==="batch")_.number("stream_id",$.streamId),_.object("batch",$.batch,x1);else if($.type==="open_cursor")_.number("stream_id",$.streamId),_.number("cursor_id",$.cursorId),_.object("batch",$.batch,x1);else if($.type==="close_cursor")_.number("cursor_id",$.cursorId);else if($.type==="fetch_cursor")_.number("cursor_id",$.cursorId),_.number("max_count",$.maxCount);else if($.type==="sequence"){if(_.number("stream_id",$.streamId),$.sql!==void 0)_.string("sql",$.sql);if($.sqlId!==void 0)_.number("sql_id",$.sqlId)}else if($.type==="describe"){if(_.number("stream_id",$.streamId),$.sql!==void 0)_.string("sql",$.sql);if($.sqlId!==void 0)_.number("sql_id",$.sqlId)}else if($.type==="store_sql")_.number("sql_id",$.sqlId),_.string("sql",$.sql);else if($.type==="close_sql")_.number("sql_id",$.sqlId);else if($.type==="get_autocommit")_.number("stream_id",$.streamId);else throw Q($,"Impossible type of Request")}function Y0(_,$){if($.sql!==void 0)_.string(1,$.sql);if($.sqlId!==void 0)_.int32(2,$.sqlId);for(let X of $.args)_.message(3,X,A8);for(let X of $.namedArgs)_.message(4,X,QZ);_.bool(5,$.wantRows)}function QZ(_,$){_.string(1,$.name),_.message(2,$.value,A8)}function M1(_,$){for(let X of $.steps)_.message(1,X,LZ)}function LZ(_,$){if($.condition!==void 0)_.message(1,$.condition,j_);_.message(2,$.stmt,Y0)}function j_(_,$){if($.type==="ok")_.uint32(1,$.step);else if($.type==="error")_.uint32(2,$.step);else if($.type==="not")_.message(3,$.cond,j_);else if($.type==="and")_.message(4,$.conds,H8);else if($.type==="or")_.message(5,$.conds,H8);else if($.type==="is_autocommit")_.message(6,void 0,U8);else throw Q($,"Impossible type of BatchCond")}function H8(_,$){for(let X of $)_.message(1,X,j_)}function A8(_,$){if($===null)_.message(1,void 0,U8);else if(typeof $==="bigint")_.sint64(2,$);else if(typeof $==="number")_.double(3,$);else if(typeof $==="string")_.string(4,$);else if($ instanceof Uint8Array)_.bytes(5,$);else if($===void 0);else throw Q($,"Impossible type of Value")}function U8(_,$){}function F8(_,$){if($.type==="hello")_.message(1,$,vZ);else if($.type==="request")_.message(2,$,CZ);else throw Q($,"Impossible type of ClientMsg")}function vZ(_,$){if($.jwt!==void 0)_.string(1,$.jwt)}function CZ(_,$){_.int32(1,$.requestId);let X=$.request;if(X.type==="open_stream")_.message(2,X,fZ);else if(X.type==="close_stream")_.message(3,X,hZ);else if(X.type==="execute")_.message(4,X,qZ);else if(X.type==="batch")_.message(5,X,yZ);else if(X.type==="open_cursor")_.message(6,X,SZ);else if(X.type==="close_cursor")_.message(7,X,pZ);else if(X.type==="fetch_cursor")_.message(8,X,gZ);else if(X.type==="sequence")_.message(9,X,bZ);else if(X.type==="describe")_.message(10,X,dZ);else if(X.type==="store_sql")_.message(11,X,mZ);else if(X.type==="close_sql")_.message(12,X,uZ);else if(X.type==="get_autocommit")_.message(13,X,cZ);else throw Q(X,"Impossible type of Request")}function fZ(_,$){_.int32(1,$.streamId)}function hZ(_,$){_.int32(1,$.streamId)}function qZ(_,$){_.int32(1,$.streamId),_.message(2,$.stmt,Y0)}function yZ(_,$){_.int32(1,$.streamId),_.message(2,$.batch,M1)}function SZ(_,$){_.int32(1,$.streamId),_.int32(2,$.cursorId),_.message(3,$.batch,M1)}function pZ(_,$){_.int32(1,$.cursorId)}function gZ(_,$){_.int32(1,$.cursorId),_.uint32(2,$.maxCount)}function bZ(_,$){if(_.int32(1,$.streamId),$.sql!==void 0)_.string(2,$.sql);if($.sqlId!==void 0)_.int32(3,$.sqlId)}function dZ(_,$){if(_.int32(1,$.streamId),$.sql!==void 0)_.string(2,$.sql);if($.sqlId!==void 0)_.int32(3,$.sqlId)}function mZ(_,$){_.int32(1,$.sqlId),_.string(2,$.sql)}function uZ(_,$){_.int32(1,$.sqlId)}function cZ(_,$){_.int32(1,$.streamId)}function c2(_){let $=$2(_.message),X=G2(_.code);return{message:$,code:X}}function G0(_){let $=V2(_.cols,V8),X=i1(_.rows).map((J)=>V2(J,K8)),Z=L2(_.affected_row_count),Y=G2(_.last_insert_rowid),G=Y!==void 0?BigInt(Y):void 0;return{cols:$,rows:X,affectedRowCount:Z,lastInsertRowid:G}}function V8(_){let $=G2(_.name),X=G2(_.decltype);return{name:$,decltype:X}}function L0(_){let $=new Map;i1(_.step_results).forEach((Z,Y)=>{if(Z!==null)$.set(Y,G0(b(Z)))});let X=new Map;return i1(_.step_errors).forEach((Z,Y)=>{if(Z!==null)X.set(Y,c2(b(Z)))}),{stepResults:$,stepErrors:X}}function v0(_){let $=$2(_.type);if($==="step_begin"){let X=L2(_.step),Z=V2(_.cols,V8);return{type:"step_begin",step:X,cols:Z}}else if($==="step_end"){let X=L2(_.affected_row_count),Z=G2(_.last_insert_rowid),Y=Z!==void 0?BigInt(Z):void 0;return{type:"step_end",affectedRowCount:X,lastInsertRowid:Y}}else if($==="step_error"){let X=L2(_.step),Z=c2(b(_.error));return{type:"step_error",step:X,error:Z}}else if($==="row")return{type:"row",row:V2(_.row,K8)};else if($==="error")return{type:"error",error:c2(b(_.error))};else throw new E("Unexpected type of CursorEntry")}function C0(_){let $=V2(_.params,nZ),X=V2(_.cols,tZ),Z=b2(_.is_explain),Y=b2(_.is_readonly);return{params:$,cols:X,isExplain:Z,isReadonly:Y}}function nZ(_){return{name:G2(_.name)}}function tZ(_){let $=$2(_.name),X=G2(_.decltype);return{name:$,decltype:X}}function K8(_){let $=$2(_.type);if($==="null")return null;else if($==="integer"){let X=$2(_.value);return BigInt(X)}else if($==="float")return L2(_.value);else if($==="text")return $2(_.value);else if($==="blob")return O1.toUint8Array($2(_.base64));else throw new E("Unexpected type of Value")}function R8(_){let $=$2(_.type);if($==="hello_ok")return{type:"hello_ok"};else if($==="hello_error")return{type:"hello_error",error:c2(b(_.error))};else if($==="response_ok"){let X=L2(_.request_id),Z=oZ(b(_.response));return{type:"response_ok",requestId:X,response:Z}}else if($==="response_error"){let X=L2(_.request_id),Z=c2(b(_.error));return{type:"response_error",requestId:X,error:Z}}else throw new E("Unexpected type of ServerMsg")}function oZ(_){let $=$2(_.type);if($==="open_stream")return{type:"open_stream"};else if($==="close_stream")return{type:"close_stream"};else if($==="execute")return{type:"execute",result:G0(b(_.result))};else if($==="batch")return{type:"batch",result:L0(b(_.result))};else if($==="open_cursor")return{type:"open_cursor"};else if($==="close_cursor")return{type:"close_cursor"};else if($==="fetch_cursor"){let X=V2(_.entries,v0),Z=b2(_.done);return{type:"fetch_cursor",entries:X,done:Z}}else if($==="sequence")return{type:"sequence"};else if($==="describe")return{type:"describe",result:C0(b(_.result))};else if($==="store_sql")return{type:"store_sql"};else if($==="close_sql")return{type:"close_sql"};else if($==="get_autocommit")return{type:"get_autocommit",isAutocommit:b2(_.is_autocommit)};else throw new E("Unexpected type of Response")}var O2={default(){return{message:"",code:void 0}},1(_,$){$.message=_.string()},2(_,$){$.code=_.string()}},n2={default(){return{cols:[],rows:[],affectedRowCount:0,lastInsertRowid:void 0}},1(_,$){$.cols.push(_.message(I8))},2(_,$){$.rows.push(_.message(x8))},3(_,$){$.affectedRowCount=Number(_.uint64())},4(_,$){$.lastInsertRowid=_.sint64()}},I8={default(){return{name:void 0,decltype:void 0}},1(_,$){$.name=_.string()},2(_,$){$.decltype=_.string()}},x8={default(){return[]},1(_,$){$.push(_.message($Y))}},N1={default(){return{stepResults:new Map,stepErrors:new Map}},1(_,$){let[X,Z]=_.message(iZ);$.stepResults.set(X,Z)},2(_,$){let[X,Z]=_.message(rZ);$.stepErrors.set(X,Z)}},iZ={default(){return[0,n2.default()]},1(_,$){$[0]=_.uint32()},2(_,$){$[1]=_.message(n2)}},rZ={default(){return[0,O2.default()]},1(_,$){$[0]=_.uint32()},2(_,$){$[1]=_.message(O2)}},f0={default(){return{type:"none"}},1(_){return _.message(sZ)},2(_){return _.message(lZ)},3(_){return _.message(aZ)},4(_){return{type:"row",row:_.message(x8)}},5(_){return{type:"error",error:_.message(O2)}}},sZ={default(){return{type:"step_begin",step:0,cols:[]}},1(_,$){$.step=_.uint32()},2(_,$){$.cols.push(_.message(I8))}},lZ={default(){return{type:"step_end",affectedRowCount:0,lastInsertRowid:void 0}},1(_,$){$.affectedRowCount=_.uint32()},2(_,$){$.lastInsertRowid=_.uint64()}},aZ={default(){return{type:"step_error",step:0,error:O2.default()}},1(_,$){$.step=_.uint32()},2(_,$){$.error=_.message(O2)}},E1={default(){return{params:[],cols:[],isExplain:!1,isReadonly:!1}},1(_,$){$.params.push(_.message(eZ))},2(_,$){$.cols.push(_.message(_Y))},3(_,$){$.isExplain=_.bool()},4(_,$){$.isReadonly=_.bool()}},eZ={default(){return{name:void 0}},1(_,$){$.name=_.string()}},_Y={default(){return{name:"",decltype:void 0}},1(_,$){$.name=_.string()},2(_,$){$.decltype=_.string()}},$Y={default(){return},1(_){return null},2(_){return _.sint64()},3(_){return _.double()},4(_){return _.string()},5(_){return _.bytes()}};var M8={default(){return{type:"none"}},1(_){return{type:"hello_ok"}},2(_){return _.message(XY)},3(_){return _.message(YY)},4(_){return _.message(ZY)}},XY={default(){return{type:"hello_error",error:O2.default()}},1(_,$){$.error=_.message(O2)}},ZY={default(){return{type:"response_error",requestId:0,error:O2.default()}},1(_,$){$.requestId=_.int32()},2(_,$){$.error=_.message(O2)}},YY={default(){return{type:"response_ok",requestId:0,response:{type:"none"}}},1(_,$){$.requestId=_.int32()},2(_,$){$.response={type:"open_stream"}},3(_,$){$.response={type:"close_stream"}},4(_,$){$.response=_.message(GY)},5(_,$){$.response=_.message(JY)},6(_,$){$.response={type:"open_cursor"}},7(_,$){$.response={type:"close_cursor"}},8(_,$){$.response=_.message(WY)},9(_,$){$.response={type:"sequence"}},10(_,$){$.response=_.message(zY)},11(_,$){$.response={type:"store_sql"}},12(_,$){$.response={type:"close_sql"}},13(_,$){$.response=_.message(DY)}},GY={default(){return{type:"execute",result:n2.default()}},1(_,$){$.result=_.message(n2)}},JY={default(){return{type:"batch",result:N1.default()}},1(_,$){$.result=_.message(N1)}},WY={default(){return{type:"fetch_cursor",entries:[],done:!1}},1(_,$){$.entries.push(_.message(f0))},2(_,$){$.done=_.bool()}},zY={default(){return{type:"describe",result:E1.default()}},1(_,$){$.result=_.message(E1)}},DY={default(){return{type:"get_autocommit",isAutocommit:!1}},1(_,$){$.isAutocommit=_.bool()}};var N8=new Map([["hrana2",{version:2,encoding:"json"}],["hrana1",{version:1,encoding:"json"}]]),B_=new Map([["hrana3-protobuf",{version:3,encoding:"protobuf"}],["hrana3",{version:3,encoding:"json"}],["hrana2",{version:2,encoding:"json"}],["hrana1",{version:1,encoding:"json"}]]);class h0 extends F1{#_;#$;#X;#Z;#Y;#G;#J;#W;#z;_streamIdAlloc;_cursorIdAlloc;#O;constructor(_,$){super();this.#_=_,this.#$=[],this.#X=!1,this.#Z=void 0,this.#Y=!1,this.#G=void 0,this.#J=!1,this.#W=new Map,this.#z=new m2,this._streamIdAlloc=new m2,this._cursorIdAlloc=new m2,this.#O=new m2,this.#_.binaryType="arraybuffer",this.#_.addEventListener("open",()=>this.#H()),this.#_.addEventListener("close",(X)=>this.#V(X)),this.#_.addEventListener("error",(X)=>this.#A(X)),this.#_.addEventListener("message",(X)=>this.#K(X)),this.#U({type:"hello",jwt:$})}#U(_){if(this.#Z!==void 0)throw new l("Trying to send a message on a closed client");if(this.#X)this.#F(_);else{let $=()=>this.#F(_),X=()=>{return};this.#$.push({openCallback:$,errorCallback:X})}}#H(){let _=this.#_.protocol;if(_===void 0){this.#D(new L("The `WebSocket.protocol` property is undefined. This most likely means that the WebSocket implementation provided by the environment is broken. If you are using Miniflare 2, please update to Miniflare 3, which fixes this problem."));return}else if(_==="")this.#G={version:1,encoding:"json"};else if(this.#G=B_.get(_),this.#G===void 0){this.#D(new E(`Unrecognized WebSocket subprotocol: ${JSON.stringify(_)}`));return}for(let $ of this.#$)$.openCallback();this.#$.length=0,this.#X=!0}#F(_){let $=this.#G.encoding;if($==="json"){let X=r1(_,O8);this.#_.send(X)}else if($==="protobuf"){let X=a1(_,F8);this.#_.send(X)}else throw Q($,"Impossible encoding")}getVersion(){return new Promise((_,$)=>{if(this.#J=!0,this.#Z!==void 0)$(this.#Z);else if(!this.#X){let X=()=>_(this.#G.version);this.#$.push({openCallback:X,errorCallback:$})}else _(this.#G.version)})}_ensureVersion(_,$){if(this.#G===void 0||!this.#J)throw new F2(`${$} is supported only on protocol version ${_} and higher, but the version supported by the WebSocket server is not yet known. Use Client.getVersion() to wait until the version is available.`);else if(this.#G.version<_)throw new F2(`${$} is supported on protocol version ${_} and higher, but the WebSocket server only supports version ${this.#G.version}`)}_sendRequest(_,$){if(this.#Z!==void 0){$.errorCallback(new g("Client is closed",this.#Z));return}let X=this.#z.alloc();this.#W.set(X,{...$,type:_.type}),this.#U({type:"request",requestId:X,request:_})}#A(_){let X=_.message??"WebSocket was closed due to an error";this.#D(new V1(X))}#V(_){let $=`WebSocket was closed with code ${_.code}`;if(_.reason)$+=`: ${_.reason}`;this.#D(new V1($))}#D(_){if(this.#Z!==void 0)return;this.#Z=_;for(let $ of this.#$)$.errorCallback(_);this.#$.length=0;for(let[$,X]of this.#W.entries())X.errorCallback(_),this.#z.free($);this.#W.clear(),this.#_.close()}#K(_){if(this.#Z!==void 0)return;try{let $,X=this.#G.encoding;if(X==="json"){if(typeof _.data!=="string"){this.#_.close(3003,"Only text messages are accepted with JSON encoding"),this.#D(new E("Received non-text message from server with JSON encoding"));return}$=a2(JSON.parse(_.data),R8)}else if(X==="protobuf"){if(!(_.data instanceof ArrayBuffer)){this.#_.close(3003,"Only binary messages are accepted with Protobuf encoding"),this.#D(new E("Received non-binary message from server with Protobuf encoding"));return}$=d2(new Uint8Array(_.data),M8)}else throw Q(X,"Impossible encoding");this.#R($)}catch($){this.#_.close(3007,"Could not handle message"),this.#D($)}}#R(_){if(_.type==="none")throw new E("Received an unrecognized ServerMsg");else if(_.type==="hello_ok"||_.type==="hello_error"){if(this.#Y)throw new E("Received a duplicated hello response");if(this.#Y=!0,_.type==="hello_error")throw v2(_.error);return}else if(!this.#Y)throw new E("Received a non-hello message before a hello response");if(_.type==="response_ok"){let $=_.requestId,X=this.#W.get($);if(this.#W.delete($),X===void 0)throw new E("Received unexpected OK response");this.#z.free($);try{if(X.type!==_.response.type)throw console.dir({responseState:X,msg:_}),new E("Received unexpected type of response");X.responseCallback(_.response)}catch(Z){throw X.errorCallback(Z),Z}}else if(_.type==="response_error"){let $=_.requestId,X=this.#W.get($);if(this.#W.delete($),X===void 0)throw new E("Received unexpected error response");this.#z.free($),X.errorCallback(v2(_.error))}else throw Q(_,"Impossible ServerMsg type")}openStream(){return X0.open(this)}storeSql(_){this._ensureVersion(2,"storeSql()");let $=this.#O.alloc(),X=new $1(this,$),Z=()=>{return},Y=(J)=>X._setClosed(J),G={type:"store_sql",sqlId:$,sql:_};return this._sendRequest(G,{responseCallback:Z,errorCallback:Y}),X}_closeSql(_){if(this.#Z!==void 0)return;let $=()=>this.#O.free(_),X=(Y)=>this.#D(Y),Z={type:"close_sql",sqlId:_};this._sendRequest(Z,{responseCallback:$,errorCallback:X})}close(){this.#D(new L("Client was manually closed"))}get closed(){return this.#Z!==void 0}}var g0=G1(y0(),1);var S0=G1(y0(),1);var Z1;if(typeof queueMicrotask<"u")Z1=queueMicrotask;else{let _=Promise.resolve();Z1=($)=>{_.then($)}}class T_{#_;#$;#X;constructor(_){this.#_=new Uint8Array(new ArrayBuffer(_)),this.#$=0,this.#X=0}get length(){return this.#X-this.#$}data(){return this.#_.slice(this.#$,this.#X)}push(_){this.#Z(_.byteLength),this.#_.set(_,this.#X),this.#X+=_.byteLength}#Z(_){if(this.#X+_<=this.#_.byteLength)return;let $=this.#X-this.#$;if($+_<=this.#_.byteLength&&2*this.#X>=this.#_.byteLength)this.#_.copyWithin(0,this.#$,this.#X);else{let X=this.#_.byteLength;do X*=2;while($+_>X);let Z=new Uint8Array(new ArrayBuffer(X));Z.set(this.#_.slice(this.#$,this.#X),0),this.#_=Z}this.#X=$,this.#$=0}shift(_){this.#$+=_}}function w8(_){let $=G2(_.baton),X=G2(_.base_url),Z=V2(_.results,HY);return{baton:$,baseUrl:X,results:Z}}function HY(_){let $=$2(_.type);if($==="ok")return{type:"ok",response:AY(b(_.response))};else if($==="error")return{type:"error",error:c2(b(_.error))};else throw new E("Unexpected type of StreamResult")}function AY(_){let $=$2(_.type);if($==="close")return{type:"close"};else if($==="execute")return{type:"execute",result:G0(b(_.result))};else if($==="batch")return{type:"batch",result:L0(b(_.result))};else if($==="sequence")return{type:"sequence"};else if($==="describe")return{type:"describe",result:C0(b(_.result))};else if($==="store_sql")return{type:"store_sql"};else if($==="close_sql")return{type:"close_sql"};else if($==="get_autocommit")return{type:"get_autocommit",isAutocommit:b2(_.is_autocommit)};else throw new E("Unexpected type of StreamResponse")}function P8(_){let $=G2(_.baton),X=G2(_.base_url);return{baton:$,baseUrl:X}}var k8={default(){return{baton:void 0,baseUrl:void 0,results:[]}},1(_,$){$.baton=_.string()},2(_,$){$.baseUrl=_.string()},3(_,$){$.results.push(_.message(UY))}},UY={default(){return{type:"none"}},1(_){return{type:"ok",response:_.message(FY)}},2(_){return{type:"error",error:_.message(O2)}}},FY={default(){return{type:"none"}},1(_){return{type:"close"}},2(_){return _.message(VY)},3(_){return _.message(KY)},4(_){return{type:"sequence"}},5(_){return _.message(RY)},6(_){return{type:"store_sql"}},7(_){return{type:"close_sql"}},8(_){return _.message(IY)}},VY={default(){return{type:"execute",result:n2.default()}},1(_,$){$.result=_.message(n2)}},KY={default(){return{type:"batch",result:N1.default()}},1(_,$){$.result=_.message(N1)}},RY={default(){return{type:"describe",result:E1.default()}},1(_,$){$.result=_.message(E1)}},IY={default(){return{type:"get_autocommit",isAutocommit:!1}},1(_,$){$.isAutocommit=_.bool()}},j8={default(){return{baton:void 0,baseUrl:void 0}},1(_,$){$.baton=_.string()},2(_,$){$.baseUrl=_.string()}};class Q_ extends $0{#_;#$;#X;#Z;#Y;#G;constructor(_,$){super();this.#_=_,this.#$=$,this.#X=void 0,this.#Z=new T_(16384),this.#Y=void 0,this.#G=!1}async open(_){if(_.body===null)throw new E("No response body for cursor request");this.#X=_.body[Symbol.asyncIterator]();let $=await this.#J(P8,j8);if($===void 0)throw new E("Empty response to cursor request");return $}next(){return this.#J(v0,f0)}close(){this._setClosed(new L("Cursor was manually closed"))}_setClosed(_){if(this.#Y!==void 0)return;if(this.#Y=_,this.#_._cursorClosed(this),this.#X!==void 0)this.#X.return()}get closed(){return this.#Y!==void 0}async#J(_,$){for(;;){if(this.#G)return;else if(this.#Y!==void 0)throw new g("Cursor is closed",this.#Y);if(this.#$==="json"){let Y=this.#W();if(Y!==void 0){let G=new TextDecoder().decode(Y),J=JSON.parse(G);return a2(J,_)}}else if(this.#$==="protobuf"){let Y=this.#z();if(Y!==void 0)return d2(Y,$)}else throw Q(this.#$,"Impossible encoding");if(this.#X===void 0)throw new l("Attempted to read from HTTP cursor before it was opened");let{value:X,done:Z}=await this.#X.next();if(Z&&this.#Z.length===0)this.#G=!0;else if(Z)throw new E("Unexpected end of cursor stream");else this.#Z.push(X)}}#W(){let _=this.#Z.data(),$=10,X=_.indexOf(10);if(X<0)return;let Z=_.slice(0,X);return this.#Z.shift(X+1),Z}#z(){let _=this.#Z.data(),$=0,X=0;for(;;){if(X>=_.byteLength)return;let Y=_[X];if($|=(Y&127)<<7*X,X+=1,!(Y&128))break}if(_.byteLength<X+$)return;let Z=_.slice(X,X+$);return this.#Z.shift(X+$),Z}}function B8(_,$){if($.baton!==void 0)_.string("baton",$.baton);_.arrayObjects("requests",$.requests,xY)}function xY(_,$){if(_.stringRaw("type",$.type),$.type==="close");else if($.type==="execute")_.object("stmt",$.stmt,Z0);else if($.type==="batch")_.object("batch",$.batch,x1);else if($.type==="sequence"){if($.sql!==void 0)_.string("sql",$.sql);if($.sqlId!==void 0)_.number("sql_id",$.sqlId)}else if($.type==="describe"){if($.sql!==void 0)_.string("sql",$.sql);if($.sqlId!==void 0)_.number("sql_id",$.sqlId)}else if($.type==="store_sql")_.number("sql_id",$.sqlId),_.string("sql",$.sql);else if($.type==="close_sql")_.number("sql_id",$.sqlId);else if($.type==="get_autocommit");else throw Q($,"Impossible type of StreamRequest")}function T8(_,$){if($.baton!==void 0)_.string("baton",$.baton);_.object("batch",$.batch,x1)}function Q8(_,$){if($.baton!==void 0)_.string(1,$.baton);for(let X of $.requests)_.message(2,X,MY)}function MY(_,$){if($.type==="close")_.message(1,$,NY);else if($.type==="execute")_.message(2,$,EY);else if($.type==="batch")_.message(3,$,wY);else if($.type==="sequence")_.message(4,$,PY);else if($.type==="describe")_.message(5,$,kY);else if($.type==="store_sql")_.message(6,$,jY);else if($.type==="close_sql")_.message(7,$,BY);else if($.type==="get_autocommit")_.message(8,$,TY);else throw Q($,"Impossible type of StreamRequest")}function NY(_,$){}function EY(_,$){_.message(1,$.stmt,Y0)}function wY(_,$){_.message(1,$.batch,M1)}function PY(_,$){if($.sql!==void 0)_.string(1,$.sql);if($.sqlId!==void 0)_.int32(2,$.sqlId)}function kY(_,$){if($.sql!==void 0)_.string(1,$.sql);if($.sqlId!==void 0)_.int32(2,$.sqlId)}function jY(_,$){_.int32(1,$.sqlId),_.string(2,$.sql)}function BY(_,$){_.int32(1,$.sqlId)}function TY(_,$){}function L8(_,$){if($.baton!==void 0)_.string(1,$.baton);_.message(2,$.batch,M1)}class p0 extends I1{#_;#$;#X;#Z;#Y;#G;#J;#W;#z;#O;#U;#H;#F;constructor(_,$,X,Z,Y){super(_.intMode);this.#_=_,this.#$=$.toString(),this.#X=X,this.#Z=Z,this.#Y=Y,this.#G=void 0,this.#J=new u2,this.#W=!1,this.#O=!1,this.#U=!1,this.#H=void 0,this.#F=new m2}client(){return this.#_}_sqlOwner(){return this}storeSql(_){let $=this.#F.alloc();return this.#A({type:"store_sql",sqlId:$,sql:_}).then(()=>{return},(X)=>this._setClosed(X)),new $1(this,$)}_closeSql(_){if(this.#H!==void 0)return;this.#A({type:"close_sql",sqlId:_}).then(()=>this.#F.free(_),($)=>this._setClosed($))}_execute(_){return this.#A({type:"execute",stmt:_}).then(($)=>{return $.result})}_batch(_){return this.#A({type:"batch",batch:_}).then(($)=>{return $.result})}_describe(_){return this.#A({type:"describe",sql:_.sql,sqlId:_.sqlId}).then(($)=>{return $.result})}_sequence(_){return this.#A({type:"sequence",sql:_.sql,sqlId:_.sqlId}).then(($)=>{return})}getAutocommit(){return this.#_._ensureVersion(3,"getAutocommit()"),this.#A({type:"get_autocommit"}).then((_)=>{return _.isAutocommit})}#A(_){return new Promise(($,X)=>{this.#V({type:"pipeline",request:_,responseCallback:$,errorCallback:X})})}_openCursor(_){return new Promise(($,X)=>{this.#V({type:"cursor",batch:_,cursorCallback:$,errorCallback:X})})}_cursorClosed(_){if(_!==this.#z)throw new l("Cursor was closed, but it was not associated with the stream");this.#z=void 0,Z1(()=>this.#D())}close(){this._setClosed(new L("Stream was manually closed"))}closeGracefully(){this.#O=!0,Z1(()=>this.#D())}get closed(){return this.#H!==void 0||this.#O}_setClosed(_){if(this.#H!==void 0)return;if(this.#H=_,this.#z!==void 0)this.#z._setClosed(_);this.#_._streamClosed(this);for(;;){let $=this.#J.shift();if($!==void 0)$.errorCallback(_);else break}if((this.#G!==void 0||this.#W)&&!this.#U)this.#J.push({type:"pipeline",request:{type:"close"},responseCallback:()=>{return},errorCallback:()=>{return}}),this.#U=!0,Z1(()=>this.#D())}#V(_){if(this.#H!==void 0)throw new g("Stream is closed",this.#H);else if(this.#O)throw new g("Stream is closing",void 0);else this.#J.push(_),Z1(()=>this.#D())}#D(){if(this.#W||this.#z!==void 0)return;if(this.#O&&this.#J.length===0){this._setClosed(new L("Stream was gracefully closed"));return}let _=this.#_._endpoint;if(_===void 0){this.#_._endpointPromise.then(()=>this.#D(),(X)=>this._setClosed(X));return}let $=this.#J.shift();if($===void 0)return;else if($.type==="pipeline"){let X=[$];for(;;){let Z=this.#J.first();if(Z!==void 0&&Z.type==="pipeline")X.push(Z),this.#J.shift();else if(Z===void 0&&this.#O&&!this.#U){X.push({type:"pipeline",request:{type:"close"},responseCallback:()=>{return},errorCallback:()=>{return}}),this.#U=!0;break}else break}this.#K(_,X)}else if($.type==="cursor")this.#R(_,$);else throw Q($,"Impossible type of QueueEntry")}#K(_,$){this.#I(()=>this.#M($,_),(X)=>LY(X,_.encoding),(X)=>X.baton,(X)=>X.baseUrl,(X)=>QY($,X),(X)=>$.forEach((Z)=>Z.errorCallback(X)))}#R(_,$){let X=new Q_(this,_.encoding);this.#z=X,this.#I(()=>this.#N($,_),(Z)=>X.open(Z),(Z)=>Z.baton,(Z)=>Z.baseUrl,(Z)=>$.cursorCallback(X),(Z)=>$.errorCallback(Z))}#I(_,$,X,Z,Y,G){let J;try{let W=_(),z=this.#Z;J=z(W)}catch(W){J=Promise.reject(W)}this.#W=!0,J.then((W)=>{if(!W.ok)return vY(W).then((z)=>{throw z});return $(W)}).then((W)=>{this.#G=X(W),this.#$=Z(W)??this.#$,Y(W)}).catch((W)=>{this._setClosed(W),G(W)}).finally(()=>{this.#W=!1,this.#D()})}#M(_,$){return this.#x(new URL($.pipelinePath,this.#$),{baton:this.#G,requests:_.map((X)=>X.request)},$.encoding,B8,Q8)}#N(_,$){if($.cursorPath===void 0)throw new F2(`Cursors are supported only on protocol version 3 and higher, but the HTTP server only supports version ${$.version}.`);return this.#x(new URL($.cursorPath,this.#$),{baton:this.#G,batch:_.batch},$.encoding,T8,L8)}#x(_,$,X,Z,Y){let G,J;if(X==="json")G=r1($,Z),J="application/json";else if(X==="protobuf")G=a1($,Y),J="application/x-protobuf";else throw Q(X,"Impossible encoding");let W=new S0.Headers;if(W.set("content-type",J),this.#X!==void 0)W.set("authorization",`Bearer ${this.#X}`);if(this.#Y!==void 0)W.set("x-turso-encryption-key",this.#Y);return new S0.Request(_.toString(),{method:"POST",headers:W,body:G})}}function QY(_,$){if($.results.length!==_.length)throw new E("Server returned unexpected number of pipeline results");for(let X=0;X<_.length;++X){let Z=$.results[X],Y=_[X];if(Z.type==="ok"){if(Z.response.type!==Y.request.type)throw new E("Received unexpected type of response");Y.responseCallback(Z.response)}else if(Z.type==="error")Y.errorCallback(v2(Z.error));else if(Z.type==="none")throw new E("Received unrecognized type of StreamResult");else throw Q(Z,"Received impossible type of StreamResult")}}async function LY(_,$){if($==="json"){let X=await _.json();return a2(X,w8)}if($==="protobuf"){let X=await _.arrayBuffer();return d2(new Uint8Array(X),k8)}throw await _.body?.cancel(),Q($,"Impossible encoding")}async function vY(_){let $=_.headers.get("content-type")??"text/plain",X=`Server returned HTTP status ${_.status}`;if($==="application/json"){let Z=await _.json();if("message"in Z)return v2(Z);return new l2(X,_.status)}if($==="text/plain"){let Z=(await _.text()).trim();if(Z!=="")X+=`: ${Z}`;return new l2(X,_.status)}return await _.body?.cancel(),new l2(X,_.status)}var CY=[{versionPath:"v3-protobuf",pipelinePath:"v3-protobuf/pipeline",cursorPath:"v3-protobuf/cursor",version:3,encoding:"protobuf"}],L_={versionPath:"v2",pipelinePath:"v2/pipeline",cursorPath:void 0,version:2,encoding:"json"};class b0 extends F1{#_;#$;#X;#Z;#Y;#G;_endpointPromise;_endpoint;constructor(_,$,X,Z,Y=2){super();if(this.#_=_,this.#$=$,this.#X=X??g0.fetch,this.#Z=Z,this.#Y=void 0,this.#G=new Set,Y==3)this._endpointPromise=fY(this.#X,this.#_),this._endpointPromise.then((G)=>this._endpoint=G,(G)=>this.#J(G));else this._endpointPromise=Promise.resolve(L_),this._endpointPromise.then((G)=>this._endpoint=G,(G)=>this.#J(G))}async getVersion(){if(this._endpoint!==void 0)return this._endpoint.version;return(await this._endpointPromise).version}_ensureVersion(_,$){if(_<=L_.version)return;else if(this._endpoint===void 0)throw new F2(`${$} is supported only on protocol version ${_} and higher, but the version supported by the HTTP server is not yet known. Use Client.getVersion() to wait until the version is available.`);else if(this._endpoint.version<_)throw new F2(`${$} is supported only on protocol version ${_} and higher, but the HTTP server only supports version ${this._endpoint.version}.`)}openStream(){if(this.#Y!==void 0)throw new g("Client is closed",this.#Y);let _=new p0(this,this.#_,this.#$,this.#X,this.#Z);return this.#G.add(_),_}_streamClosed(_){this.#G.delete(_)}close(){this.#J(new L("Client was manually closed"))}get closed(){return this.#Y!==void 0}#J(_){if(this.#Y!==void 0)return;this.#Y=_;for(let $ of Array.from(this.#G))$._setClosed(new g("Client was closed",_))}}async function fY(_,$){let X=_;for(let Z of CY){let Y=new URL(Z.versionPath,$),G=new g0.Request(Y.toString(),{method:"GET"}),J=await X(G);if(await J.arrayBuffer(),J.ok)return Z}return L_}var h_=G1(y0(),1);function v_(_,$,X=2){if(typeof g2>"u")throw new o1("WebSockets are not supported in this environment");var Z=void 0;if(X==3)Z=Array.from(B_.keys());else Z=Array.from(N8.keys());let Y=new g2(_,Z);return new h0(Y,$)}function C_(_,$,X,Z,Y=2){return new b0(_ instanceof URL?_:new URL(_),$,X,Z,Y)}class W0{#_;#$;#X;constructor(_,$){this.#_=_,this.#$=$,this.#X=void 0}execute(_){return this.batch([_]).then(($)=>$[0])}async batch(_){let $=this._getStream();if($.closed)throw new w("Cannot execute statements because the transaction is closed","TRANSACTION_CLOSED");try{let X=_.map(C2),Z;if(this.#X===void 0){this._getSqlCache().apply(X);let G=$.batch(this.#$>=3),J=G.step(),W=J.run(S2(this.#_)),z=J;Z=X.map((O)=>{let U=G.step().condition(q.ok(z));if(this.#$>=3)U.condition(q.not(q.isAutocommit(G)));let R=U.query(O);return R.catch(()=>{return}),z=U,R}),this.#X=G.execute().then(()=>W).then(()=>{return});try{await this.#X}catch(O){throw this.close(),O}}else{if(this.#$<3)await this.#X;this._getSqlCache().apply(X);let G=$.batch(this.#$>=3),J=void 0;Z=X.map((W)=>{let z=G.step();if(J!==void 0)z.condition(q.ok(J));if(this.#$>=3)z.condition(q.not(q.isAutocommit(G)));let O=z.query(W);return O.catch(()=>{return}),J=z,O}),await G.execute()}let Y=[];for(let G=0;G<Z.length;G++)try{let J=await Z[G];if(J===void 0)throw new i("Statement in a transaction was not executed, probably because the transaction has been rolled back",G,"TRANSACTION_CLOSED");Y.push(P1(J))}catch(J){if(J instanceof i)throw J;let W=C(J);if(W instanceof w)throw new i(W.message,G,W.code,W.extendedCode,W.rawCode,W.cause instanceof Error?W.cause:void 0);throw W}return Y}catch(X){throw C(X)}}async executeMultiple(_){let $=this._getStream();if($.closed)throw new w("Cannot execute statements because the transaction is closed","TRANSACTION_CLOSED");try{if(this.#X===void 0){this.#X=$.run(S2(this.#_)).then(()=>{return});try{await this.#X}catch(X){throw this.close(),X}}else await this.#X;await $.sequence(_)}catch(X){throw C(X)}}async rollback(){try{let _=this._getStream();if(_.closed)return;if(this.#X!==void 0);else return;let $=_.run("ROLLBACK").catch((X)=>{throw C(X)});_.closeGracefully(),await $}catch(_){throw C(_)}finally{this.close()}}async commit(){try{let _=this._getStream();if(_.closed)throw new w("Cannot commit the transaction because it is already closed","TRANSACTION_CLOSED");if(this.#X!==void 0)await this.#X;else return;let $=_.run("COMMIT").catch((X)=>{throw C(X)});_.closeGracefully(),await $}catch(_){throw C(_)}finally{this.close()}}}async function w1(_,$,X,Z,Y=!1){if(Y)X.step().run("PRAGMA foreign_keys=off");let G=X.step(),J=G.run(S2(_)),W=G,z=Z.map((k)=>{let x=X.step().condition(q.ok(W));if($>=3)x.condition(q.not(q.isAutocommit(X)));let M=x.query(k);return W=x,M}),O=X.step().condition(q.ok(W));if($>=3)O.condition(q.not(q.isAutocommit(X)));let U=O.run("COMMIT");if(X.step().condition(q.not(q.ok(O))).run("ROLLBACK").catch((k)=>{return}),Y)X.step().run("PRAGMA foreign_keys=on");await X.execute();let P=[];await J;for(let k=0;k<z.length;k++)try{let x=await z[k];if(x===void 0)throw new i("Statement in a batch was not executed, probably because the transaction has been rolled back",k,"TRANSACTION_CLOSED");P.push(P1(x))}catch(x){if(x instanceof i)throw x;let M=C(x);if(M instanceof w)throw new i(M.message,k,M.code,M.extendedCode,M.rawCode,M.cause instanceof Error?M.cause:void 0);throw M}return await U,P}function C2(_){let $,X;if(Array.isArray(_))[$,X]=_;else if(typeof _==="string")$=_;else $=_.sql,X=_.args;let Z=new _0($);if(X)if(Array.isArray(X))Z.bindIndexes(X);else for(let[Y,G]of Object.entries(X))Z.bindName(Y,G);return Z}function P1(_){let $=_.columnNames.map((J)=>J??""),X=_.columnDecltypes.map((J)=>J??""),Z=_.rows,Y=_.affectedRowCount,G=_.lastInsertRowid!==void 0?_.lastInsertRowid:void 0;return new H1($,X,Z,Y,G)}function C(_){if(_ instanceof L){let $=v8(_);return new w(_.message,$,void 0,void 0,_)}return _}function v8(_){if(_ instanceof t1&&_.code!==void 0)return _.code;else if(_ instanceof E)return"HRANA_PROTO_ERROR";else if(_ instanceof g)return _.cause instanceof L?v8(_.cause):"HRANA_CLOSED_ERROR";else if(_ instanceof V1)return"HRANA_WEBSOCKET_ERROR";else if(_ instanceof l2)return"SERVER_ERROR";else if(_ instanceof F2)return"PROTOCOL_VERSION_ERROR";else if(_ instanceof l)return"INTERNAL_ERROR";else return"UNKNOWN"}class k1{#_;#$;capacity;constructor(_,$){this.#_=_,this.#$=new C8,this.capacity=$}apply(_){if(this.capacity<=0)return;let $=new Set;for(let X of _){if(typeof X.sql!=="string")continue;let Z=X.sql;if(Z.length>=5000)continue;let Y=this.#$.get(Z);if(Y===void 0){while(this.#$.size+1>this.capacity){let[G,J]=this.#$.peekLru();if($.has(J))break;J.close(),this.#$.delete(G)}if(this.#$.size+1<=this.capacity)Y=this.#_.storeSql(Z),this.#$.set(Z,Y)}if(Y!==void 0)X.sql=Y,$.add(Y)}}}class C8{#_;constructor(){this.#_=new Map}get(_){let $=this.#_.get(_);if($!==void 0)this.#_.delete(_),this.#_.set(_,$);return $}set(_,$){this.#_.set(_,$)}peekLru(){for(let _ of this.#_.entries())return _;return}delete(_){this.#_.delete(_)}get size(){return this.#_.size}}var y8=G1(q_(),1);function S8(_){if(_.scheme!=="wss"&&_.scheme!=="ws")throw new w(`The WebSocket client supports only "libsql:", "wss:" and "ws:" URLs, got ${JSON.stringify(_.scheme+":")}. For more information, please read ${N2}`,"URL_SCHEME_NOT_SUPPORTED");if(_.encryptionKey!==void 0)throw new w("Encryption key is not supported by the remote client.","ENCRYPTION_KEY_NOT_SUPPORTED");if(_.scheme==="ws"&&_.tls)throw new w('A "ws:" URL cannot opt into TLS by using ?tls=1',"URL_INVALID");else if(_.scheme==="wss"&&!_.tls)throw new w('A "wss:" URL cannot opt out of TLS by using ?tls=0',"URL_INVALID");let $=m1(_.scheme,_.authority,_.path),X;try{X=v_($,_.authToken)}catch(Z){if(Z instanceof o1){let Y=_.scheme==="wss"?"https":"http",G=m1(Y,_.authority,_.path);throw new w(`This environment does not support WebSockets, please switch to the HTTP client by using a "${Y}:" URL (${JSON.stringify(G)}). For more information, please read ${N2}`,"WEBSOCKETS_NOT_SUPPORTED")}throw C(Z)}return new p8(X,$,_.authToken,_.intMode,_.concurrency)}var yY=60000,q8=100;class p8{#_;#$;#X;#Z;#Y;closed;protocol;#G;#J;constructor(_,$,X,Z,Y){this.#_=$,this.#$=X,this.#X=Z,this.#Z=this.#z(_),this.#Y=void 0,this.closed=!1,this.protocol="ws",this.#J=y8.default(Y)}async limit(_){return this.#J(_)}async execute(_,$){let X;if(typeof _==="string")X={sql:_,args:$||[]};else X=_;return this.limit(async()=>{let Z=await this.#W();try{let Y=C2(X);Z.conn.sqlCache.apply([Y]);let G=Z.stream.query(Y);Z.stream.closeGracefully();let J=await G;return P1(J)}catch(Y){throw C(Y)}finally{this._closeStream(Z)}})}async batch(_,$="deferred"){return this.limit(async()=>{let X=await this.#W();try{let Y=_.map((O)=>{if(Array.isArray(O))return{sql:O[0],args:O[1]||[]};return O}).map(C2),G=await X.conn.client.getVersion();X.conn.sqlCache.apply(Y);let J=X.stream.batch(G>=3);return await w1($,G,J,Y)}catch(Z){throw C(Z)}finally{this._closeStream(X)}})}async migrate(_){return this.limit(async()=>{let $=await this.#W();try{let X=_.map(C2),Z=await $.conn.client.getVersion(),Y=$.stream.batch(Z>=3);return await w1("deferred",Z,Y,X,!0)}catch(X){throw C(X)}finally{this._closeStream($)}})}async transaction(_="write"){return this.limit(async()=>{let $=await this.#W();try{let X=await $.conn.client.getVersion();return new g8(this,$,_,X)}catch(X){throw this._closeStream($),C(X)}})}async executeMultiple(_){return this.limit(async()=>{let $=await this.#W();try{let X=$.stream.sequence(_);$.stream.closeGracefully(),await X}catch(X){throw C(X)}finally{this._closeStream($)}})}sync(){throw new w("sync not supported in ws mode","SYNC_NOT_SUPPORTED")}async#W(){if(this.closed)throw new w("The client is closed","CLIENT_CLOSED");if(new Date().valueOf()-this.#Z.openTime.valueOf()>yY&&this.#Y===void 0){let Z=this.#z();this.#Y=Z,Z.client.getVersion().then((Y)=>{if(this.#Z!==Z){if(this.#Z.streamStates.size===0)this.#Z.client.close()}this.#Z=Z,this.#Y=void 0},(Y)=>{this.#Y=void 0})}if(this.#Z.client.closed)try{if(this.#Y!==void 0)this.#Z=this.#Y;else this.#Z=this.#z()}catch(Z){throw C(Z)}let X=this.#Z;try{if(X.useSqlCache===void 0){if(X.useSqlCache=await X.client.getVersion()>=2,X.useSqlCache)X.sqlCache.capacity=q8}let Z=X.client.openStream();Z.intMode=this.#X;let Y={conn:X,stream:Z};return X.streamStates.add(Y),Y}catch(Z){throw C(Z)}}#z(_){try{return _??=v_(this.#_,this.#$),{client:_,useSqlCache:void 0,sqlCache:new k1(_,0),openTime:new Date,streamStates:new Set}}catch($){throw C($)}}async reconnect(){try{for(let X of Array.from(this.#Z.streamStates))try{X.stream.close()}catch{}this.#Z.client.close()}catch{}if(this.#Y){try{this.#Y.client.close()}catch{}this.#Y=void 0}let _=this.#z(),$=await _.client.getVersion();if(_.useSqlCache=$>=2,_.useSqlCache)_.sqlCache.capacity=q8;this.#Z=_,this.closed=!1}_closeStream(_){_.stream.close();let $=_.conn;if($.streamStates.delete(_),$.streamStates.size===0&&$!==this.#Z)$.client.close()}close(){if(this.#Z.client.close(),this.closed=!0,this.#Y){try{this.#Y.client.close()}catch{}this.#Y=void 0}this.closed=!0}}class g8 extends W0{#_;#$;constructor(_,$,X,Z){super(X,Z);this.#_=_,this.#$=$}_getStream(){return this.#$.stream}_getSqlCache(){return this.#$.conn.sqlCache}close(){this.#_._closeStream(this.#$)}get closed(){return this.#$.stream.closed}}var b8=G1(q_(),1);function d8(_){if(_.scheme!=="https"&&_.scheme!=="http")throw new w(`The HTTP client supports only "libsql:", "https:" and "http:" URLs, got ${JSON.stringify(_.scheme+":")}. For more information, please read ${N2}`,"URL_SCHEME_NOT_SUPPORTED");if(_.encryptionKey!==void 0)throw new w("Encryption key is not supported by the remote client.","ENCRYPTION_KEY_NOT_SUPPORTED");if(_.scheme==="http"&&_.tls)throw new w('A "http:" URL cannot opt into TLS by using ?tls=1',"URL_INVALID");else if(_.scheme==="https"&&!_.tls)throw new w('A "https:" URL cannot opt out of TLS by using ?tls=0',"URL_INVALID");let $=m1(_.scheme,_.authority,_.path);return new u8($,_.authToken,_.intMode,_.fetch,_.concurrency,_.remoteEncryptionKey)}var m8=30;class u8{#_;protocol;#$;#X;#Z;#Y;#G;#J;#W;constructor(_,$,X,Z,Y,G){this.#$=_,this.#G=$,this.#X=X,this.#Z=Z,this.#Y=Y,this.#J=G,this.#_=C_(this.#$,this.#G,this.#Z,G),this.#_.intMode=this.#X,this.protocol="http",this.#W=b8.default(this.#Y)}async limit(_){return this.#W(_)}async execute(_,$){let X;if(typeof _==="string")X={sql:_,args:$||[]};else X=_;return this.limit(async()=>{try{let Z=C2(X),Y,G=this.#_.openStream();try{Y=G.query(Z)}finally{G.closeGracefully()}let J=await Y;return P1(J)}catch(Z){throw C(Z)}})}async batch(_,$="deferred"){return this.limit(async()=>{try{let Z=_.map((z)=>{if(Array.isArray(z))return{sql:z[0],args:z[1]||[]};return z}).map(C2),Y=await this.#_.getVersion(),G,J=this.#_.openStream();try{new k1(J,m8).apply(Z);let O=J.batch(!1);G=w1($,Y,O,Z)}finally{J.closeGracefully()}return await G}catch(X){throw C(X)}})}async migrate(_){return this.limit(async()=>{try{let $=_.map(C2),X=await this.#_.getVersion(),Z,Y=this.#_.openStream();try{let J=Y.batch(!1);Z=w1("deferred",X,J,$,!0)}finally{Y.closeGracefully()}return await Z}catch($){throw C($)}})}async transaction(_="write"){return this.limit(async()=>{try{let $=await this.#_.getVersion();return new c8(this.#_.openStream(),_,$)}catch($){throw C($)}})}async executeMultiple(_){return this.limit(async()=>{try{let $,X=this.#_.openStream();try{$=X.sequence(_)}finally{X.closeGracefully()}await $}catch($){throw C($)}})}sync(){throw new w("sync not supported in http mode","SYNC_NOT_SUPPORTED")}close(){this.#_.close()}async reconnect(){try{if(!this.closed)this.#_.close()}finally{this.#_=C_(this.#$,this.#G,this.#Z,this.#J),this.#_.intMode=this.#X}}get closed(){return this.#_.closed}}class c8 extends W0{#_;#$;constructor(_,$,X){super($,X);this.#_=_,this.#$=new k1(_,m8)}_getStream(){return this.#_}_getSqlCache(){return this.#$}close(){this.#_.close()}get closed(){return this.#_.closed}}function j1(_){return SY(c1(_,!0))}function SY(_){if(_.scheme==="wss"||_.scheme==="ws")return S8(_);else if(_.scheme==="https"||_.scheme==="http")return d8(_);else return s$(_)}class d{static[H]="SelectionProxyHandler";config;constructor(_){this.config={..._}}get(_,$){if($==="_")return{..._._,selectedFields:new Proxy(_._.selectedFields,this)};if($===h)return{..._[h],selectedFields:new Proxy(_[h].selectedFields,this)};if(typeof $==="symbol")return _[$];let Z=(A(_,f)?_._.selectedFields:A(_,W2)?_[h].selectedFields:_)[$];if(A(Z,K.Aliased)){if(this.config.sqlAliasedBehavior==="sql"&&!Z.isSelectionField)return Z.sql;let Y=Z.clone();return Y.isSelectionField=!0,Y}if(A(Z,K)){if(this.config.sqlBehavior==="sql")return Z;throw Error(`You tried to reference "${$}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`)}if(A(Z,T)){if(this.config.alias)return new Proxy(Z,new J1(new Proxy(Z.table,new y1(this.config.alias,this.config.replaceOriginalName??!1))));return Z}if(typeof Z!=="object"||Z===null)return Z;return new Proxy(Z,new d(this.config))}}class y_{static[H]="SQLiteForeignKeyBuilder";reference;_onUpdate;_onDelete;constructor(_,$){if(this.reference=()=>{let{name:X,columns:Z,foreignColumns:Y}=_();return{name:X,columns:Z,foreignTable:Y[0].table,foreignColumns:Y}},$)this._onUpdate=$.onUpdate,this._onDelete=$.onDelete}onUpdate(_){return this._onUpdate=_,this}onDelete(_){return this._onDelete=_,this}build(_){return new n8(_,this)}}class n8{constructor(_,$){this.table=_,this.reference=$.reference,this.onUpdate=$._onUpdate,this.onDelete=$._onDelete}static[H]="SQLiteForeignKey";reference;onUpdate;onDelete;getName(){let{name:_,columns:$,foreignColumns:X}=this.reference(),Z=$.map((J)=>J.name),Y=X.map((J)=>J.name),G=[this.table[Z2],...Z,X[0].table[Z2],...Y];return _??`${G.join("_")}_fk`}}function t8(_,$){return`${_[Z2]}_${$.join("_")}_unique`}class n extends __{static[H]="SQLiteColumnBuilder";foreignKeyConfigs=[];references(_,$={}){return this.foreignKeyConfigs.push({ref:_,actions:$}),this}unique(_){return this.config.isUnique=!0,this.config.uniqueName=_,this}generatedAlwaysAs(_,$){return this.config.generated={as:_,type:"always",mode:$?.mode??"virtual"},this}buildForeignKeys(_,$){return this.foreignKeyConfigs.map(({ref:X,actions:Z})=>{return((Y,G)=>{let J=new y_(()=>{let W=Y();return{columns:[_],foreignColumns:[W]}});if(G.onUpdate)J.onUpdate(G.onUpdate);if(G.onDelete)J.onDelete(G.onDelete);return J.build($)})(X,Z)})}}class y extends T{constructor(_,$){if(!$.uniqueName)$.uniqueName=t8(_,[$.name]);super(_,$);this.table=_}static[H]="SQLiteColumn"}class o8 extends n{static[H]="SQLiteBigIntBuilder";constructor(_){super(_,"bigint","SQLiteBigInt")}build(_){return new i8(_,this.config)}}class i8 extends y{static[H]="SQLiteBigInt";getSQLType(){return"blob"}mapFromDriverValue(_){if(typeof Buffer<"u"&&Buffer.from){let $=Buffer.isBuffer(_)?_:_ instanceof ArrayBuffer?Buffer.from(_):_.buffer?Buffer.from(_.buffer,_.byteOffset,_.byteLength):Buffer.from(_);return BigInt($.toString("utf8"))}return BigInt(H_.decode(_))}mapToDriverValue(_){return Buffer.from(_.toString())}}class r8 extends n{static[H]="SQLiteBlobJsonBuilder";constructor(_){super(_,"json","SQLiteBlobJson")}build(_){return new s8(_,this.config)}}class s8 extends y{static[H]="SQLiteBlobJson";getSQLType(){return"blob"}mapFromDriverValue(_){if(typeof Buffer<"u"&&Buffer.from){let $=Buffer.isBuffer(_)?_:_ instanceof ArrayBuffer?Buffer.from(_):_.buffer?Buffer.from(_.buffer,_.byteOffset,_.byteLength):Buffer.from(_);return JSON.parse($.toString("utf8"))}return JSON.parse(H_.decode(_))}mapToDriverValue(_){return Buffer.from(JSON.stringify(_))}}class l8 extends n{static[H]="SQLiteBlobBufferBuilder";constructor(_){super(_,"buffer","SQLiteBlobBuffer")}build(_){return new a8(_,this.config)}}class a8 extends y{static[H]="SQLiteBlobBuffer";mapFromDriverValue(_){if(Buffer.isBuffer(_))return _;return Buffer.from(_)}getSQLType(){return"blob"}}function e8(_,$){let{name:X,config:Z}=M2(_,$);if(Z?.mode==="json")return new r8(X);if(Z?.mode==="bigint")return new o8(X);return new l8(X)}class _4 extends n{static[H]="SQLiteCustomColumnBuilder";constructor(_,$,X){super(_,"custom","SQLiteCustomColumn");this.config.fieldConfig=$,this.config.customTypeParams=X}build(_){return new $4(_,this.config)}}class $4 extends y{static[H]="SQLiteCustomColumn";sqlName;mapTo;mapFrom;constructor(_,$){super(_,$);this.sqlName=$.customTypeParams.dataType($.fieldConfig),this.mapTo=$.customTypeParams.toDriver,this.mapFrom=$.customTypeParams.fromDriver}getSQLType(){return this.sqlName}mapFromDriverValue(_){return typeof this.mapFrom==="function"?this.mapFrom(_):_}mapToDriverValue(_){return typeof this.mapTo==="function"?this.mapTo(_):_}}function X4(_){return($,X)=>{let{name:Z,config:Y}=M2($,X);return new _4(Z,Y,_)}}class d0 extends n{static[H]="SQLiteBaseIntegerBuilder";constructor(_,$,X){super(_,$,X);this.config.autoIncrement=!1}primaryKey(_){if(_?.autoIncrement)this.config.autoIncrement=!0;return this.config.hasDefault=!0,super.primaryKey()}}class m0 extends y{static[H]="SQLiteBaseInteger";autoIncrement=this.config.autoIncrement;getSQLType(){return"integer"}}class Z4 extends d0{static[H]="SQLiteIntegerBuilder";constructor(_){super(_,"number","SQLiteInteger")}build(_){return new Y4(_,this.config)}}class Y4 extends m0{static[H]="SQLiteInteger"}class G4 extends d0{static[H]="SQLiteTimestampBuilder";constructor(_,$){super(_,"date","SQLiteTimestamp");this.config.mode=$}defaultNow(){return this.default(D`(cast((julianday('now') - 2440587.5)*86400000 as integer))`)}build(_){return new J4(_,this.config)}}class J4 extends m0{static[H]="SQLiteTimestamp";mode=this.config.mode;mapFromDriverValue(_){if(this.config.mode==="timestamp")return new Date(_*1000);return new Date(_)}mapToDriverValue(_){let $=_.getTime();if(this.config.mode==="timestamp")return Math.floor($/1000);return $}}class W4 extends d0{static[H]="SQLiteBooleanBuilder";constructor(_,$){super(_,"boolean","SQLiteBoolean");this.config.mode=$}build(_){return new z4(_,this.config)}}class z4 extends m0{static[H]="SQLiteBoolean";mode=this.config.mode;mapFromDriverValue(_){return Number(_)===1}mapToDriverValue(_){return _?1:0}}function H2(_,$){let{name:X,config:Z}=M2(_,$);if(Z?.mode==="timestamp"||Z?.mode==="timestamp_ms")return new G4(X,Z.mode);if(Z?.mode==="boolean")return new W4(X,Z.mode);return new Z4(X)}class D4 extends n{static[H]="SQLiteNumericBuilder";constructor(_){super(_,"string","SQLiteNumeric")}build(_){return new O4(_,this.config)}}class O4 extends y{static[H]="SQLiteNumeric";mapFromDriverValue(_){if(typeof _==="string")return _;return String(_)}getSQLType(){return"numeric"}}class H4 extends n{static[H]="SQLiteNumericNumberBuilder";constructor(_){super(_,"number","SQLiteNumericNumber")}build(_){return new A4(_,this.config)}}class A4 extends y{static[H]="SQLiteNumericNumber";mapFromDriverValue(_){if(typeof _==="number")return _;return Number(_)}mapToDriverValue=String;getSQLType(){return"numeric"}}class U4 extends n{static[H]="SQLiteNumericBigIntBuilder";constructor(_){super(_,"bigint","SQLiteNumericBigInt")}build(_){return new F4(_,this.config)}}class F4 extends y{static[H]="SQLiteNumericBigInt";mapFromDriverValue=BigInt;mapToDriverValue=String;getSQLType(){return"numeric"}}function V4(_,$){let{name:X,config:Z}=M2(_,$),Y=Z?.mode;return Y==="number"?new H4(X):Y==="bigint"?new U4(X):new D4(X)}class K4 extends n{static[H]="SQLiteRealBuilder";constructor(_){super(_,"number","SQLiteReal")}build(_){return new R4(_,this.config)}}class R4 extends y{static[H]="SQLiteReal";getSQLType(){return"real"}}function I4(_){return new K4(_??"")}class x4 extends n{static[H]="SQLiteTextBuilder";constructor(_,$){super(_,"string","SQLiteText");this.config.enumValues=$.enum,this.config.length=$.length}build(_){return new M4(_,this.config)}}class M4 extends y{static[H]="SQLiteText";enumValues=this.config.enumValues;length=this.config.length;constructor(_,$){super(_,$)}getSQLType(){return`text${this.config.length?`(${this.config.length})`:""}`}}class N4 extends n{static[H]="SQLiteTextJsonBuilder";constructor(_){super(_,"json","SQLiteTextJson")}build(_){return new E4(_,this.config)}}class E4 extends y{static[H]="SQLiteTextJson";getSQLType(){return"text"}mapFromDriverValue(_){return JSON.parse(_)}mapToDriverValue(_){return JSON.stringify(_)}}function I(_,$={}){let{name:X,config:Z}=M2(_,$);if(Z.mode==="json")return new N4(X);return new x4(X,Z)}function w4(){return{blob:e8,customType:X4,integer:H2,numeric:V4,real:I4,text:I}}var S_=Symbol.for("drizzle:SQLiteInlineForeignKeys");class t extends F{static[H]="SQLiteTable";static Symbol=Object.assign({},F.Symbol,{InlineForeignKeys:S_});[F.Symbol.Columns];[S_]=[];[F.Symbol.ExtraConfigBuilder]=void 0}function pY(_,$,X,Z,Y=_){let G=new t(_,Z,Y),J=typeof $==="function"?$(w4()):$,W=Object.fromEntries(Object.entries(J).map(([O,U])=>{let R=U;R.setName(O);let P=R.build(G);return G[S_].push(...R.buildForeignKeys(P,G)),[O,P]})),z=Object.assign(G,W);if(z[F.Symbol.Columns]=W,z[F.Symbol.ExtraConfigColumns]=W,X)z[t.Symbol.ExtraConfigBuilder]=X;return z}var K2=(_,$,X)=>{return pY(_,$,X)};function R2(_){if(A(_,t))return[`${_[F.Symbol.BaseName]}`];if(A(_,f))return _._.usedTables??[];if(A(_,K))return _.usedTables??[];return[]}class u0 extends a{constructor(_,$,X,Z){super();this.table=_,this.session=$,this.dialect=X,this.config={table:_,withList:Z}}static[H]="SQLiteDelete";config;where(_){return this.config.where=_,this}orderBy(..._){if(typeof _[0]==="function"){let $=_[0](new Proxy(this.config.table[F.Symbol.Columns],new d({sqlAliasedBehavior:"alias",sqlBehavior:"sql"}))),X=Array.isArray($)?$:[$];this.config.orderBy=X}else{let $=_;this.config.orderBy=$}return this}limit(_){return this.config.limit=_,this}returning(_=this.table[t.Symbol.Columns]){return this.config.returning=z2(_),this}getSQL(){return this.dialect.buildDeleteQuery(this.config)}toSQL(){let{typings:_,...$}=this.dialect.sqlToQuery(this.getSQL());return $}_prepare(_=!0){return this.session[_?"prepareOneTimeQuery":"prepareQuery"](this.dialect.sqlToQuery(this.getSQL()),this.config.returning,this.config.returning?"all":"run",!0,void 0,{type:"delete",tables:R2(this.config.table)})}prepare(){return this._prepare(!1)}run=(_)=>{return this._prepare().run(_)};all=(_)=>{return this._prepare().all(_)};get=(_)=>{return this._prepare().get(_)};values=(_)=>{return this._prepare().values(_)};async execute(_){return this._prepare().execute(_)}$dynamic(){return this}}function gY(_){return(_.replace(/['\u2019]/g,"").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g)??[]).map((X)=>X.toLowerCase()).join("_")}function bY(_){return(_.replace(/['\u2019]/g,"").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g)??[]).reduce((X,Z,Y)=>{let G=Y===0?Z.toLowerCase():`${Z[0].toUpperCase()}${Z.slice(1)}`;return X+G},"")}function dY(_){return _}class p_{static[H]="CasingCache";cache={};cachedTables={};convert;constructor(_){this.convert=_==="snake_case"?gY:_==="camelCase"?bY:dY}getColumnCasing(_){if(!_.keyAsName)return _.name;let $=_.table[F.Symbol.Schema]??"public",X=_.table[F.Symbol.OriginalName],Z=`${$}.${X}.${_.name}`;if(!this.cache[Z])this.cacheTable(_.table);return this.cache[Z]}cacheTable(_){let $=_[F.Symbol.Schema]??"public",X=_[F.Symbol.OriginalName],Z=`${$}.${X}`;if(!this.cachedTables[Z]){for(let Y of Object.values(_[F.Symbol.Columns])){let G=`${Z}.${Y.name}`;this.cache[G]=this.convert(Y.name)}this.cachedTables[Z]=!0}}clearCache(){this.cache={},this.cachedTables={}}}class Y1 extends W2{static[H]="SQLiteViewBase"}class B1{static[H]="SQLiteDialect";casing;constructor(_){this.casing=new p_(_?.casing)}escapeName(_){return`"${_}"`}escapeParam(_){return"?"}escapeString(_){return`'${_.replace(/'/g,"''")}'`}buildWithCTE(_){if(!_?.length)return;let $=[D`with `];for(let[X,Z]of _.entries())if($.push(D`${D.identifier(Z._.alias)} as (${Z._.sql})`),X<_.length-1)$.push(D`, `);return $.push(D` `),D.join($)}buildDeleteQuery({table:_,where:$,returning:X,withList:Z,limit:Y,orderBy:G}){let J=this.buildWithCTE(Z),W=X?D` returning ${this.buildSelection(X,{isSingleTable:!0})}`:void 0,z=$?D` where ${$}`:void 0,O=this.buildOrderBy(G),U=this.buildLimit(Y);return D`${J}delete from ${_}${z}${W}${O}${U}`}buildUpdateSet(_,$){let X=_[F.Symbol.Columns],Z=Object.keys(X).filter((G)=>$[G]!==void 0||X[G]?.onUpdateFn!==void 0),Y=Z.length;return D.join(Z.flatMap((G,J)=>{let W=X[G],z=W.onUpdateFn?.(),O=$[G]??(A(z,K)?z:D.param(z,W)),U=D`${D.identifier(this.casing.getColumnCasing(W))} = ${O}`;if(J<Y-1)return[U,D.raw(", ")];return[U]}))}buildUpdateQuery({table:_,set:$,where:X,returning:Z,withList:Y,joins:G,from:J,limit:W,orderBy:z}){let O=this.buildWithCTE(Y),U=this.buildUpdateSet(_,$),R=J&&D.join([D.raw(" from "),this.buildFromTable(J)]),P=this.buildJoins(G),k=Z?D` returning ${this.buildSelection(Z,{isSingleTable:!0})}`:void 0,x=X?D` where ${X}`:void 0,M=this.buildOrderBy(z),j=this.buildLimit(W);return D`${O}update ${_} set ${U}${R}${P}${x}${k}${M}${j}`}buildSelection(_,{isSingleTable:$=!1}={}){let X=_.length,Z=_.flatMap(({field:Y},G)=>{let J=[];if(A(Y,K.Aliased)&&Y.isSelectionField)J.push(D.identifier(Y.fieldAlias));else if(A(Y,K.Aliased)||A(Y,K)){let W=A(Y,K.Aliased)?Y.sql:Y;if($)J.push(new K(W.queryChunks.map((z)=>{if(A(z,T))return D.identifier(this.casing.getColumnCasing(z));return z})));else J.push(W);if(A(Y,K.Aliased))J.push(D` as ${D.identifier(Y.fieldAlias)}`)}else if(A(Y,T)){let W=Y.table[F.Symbol.Name];if(Y.columnType==="SQLiteNumericBigInt")if($)J.push(D`cast(${D.identifier(this.casing.getColumnCasing(Y))} as text)`);else J.push(D`cast(${D.identifier(W)}.${D.identifier(this.casing.getColumnCasing(Y))} as text)`);else if($)J.push(D.identifier(this.casing.getColumnCasing(Y)));else J.push(D`${D.identifier(W)}.${D.identifier(this.casing.getColumnCasing(Y))}`)}else if(A(Y,f)){let W=Object.entries(Y._.selectedFields);if(W.length===1){let z=W[0][1],O=A(z,K)?z.decoder:A(z,T)?{mapFromDriverValue:(U)=>z.mapFromDriverValue(U)}:z.sql.decoder;if(O)Y._.sql.decoder=O}J.push(Y)}if(G<X-1)J.push(D`, `);return J});return D.join(Z)}buildJoins(_){if(!_||_.length===0)return;let $=[];if(_)for(let[X,Z]of _.entries()){if(X===0)$.push(D` `);let Y=Z.table,G=Z.on?D` on ${Z.on}`:void 0;if(A(Y,t)){let J=Y[t.Symbol.Name],W=Y[t.Symbol.Schema],z=Y[t.Symbol.OriginalName],O=J===z?void 0:Z.alias;$.push(D`${D.raw(Z.joinType)} join ${W?D`${D.identifier(W)}.`:void 0}${D.identifier(z)}${O&&D` ${D.identifier(O)}`}${G}`)}else $.push(D`${D.raw(Z.joinType)} join ${Y}${G}`);if(X<_.length-1)$.push(D` `)}return D.join($)}buildLimit(_){return typeof _==="object"||typeof _==="number"&&_>=0?D` limit ${_}`:void 0}buildOrderBy(_){let $=[];if(_){for(let[X,Z]of _.entries())if($.push(Z),X<_.length-1)$.push(D`, `)}return $.length>0?D` order by ${D.join($)}`:void 0}buildFromTable(_){if(A(_,F)&&_[F.Symbol.IsAlias])return D`${D`${D.identifier(_[F.Symbol.Schema]??"")}.`.if(_[F.Symbol.Schema])}${D.identifier(_[F.Symbol.OriginalName])} ${D.identifier(_[F.Symbol.Name])}`;return _}buildSelectQuery({withList:_,fields:$,fieldsFlat:X,where:Z,having:Y,table:G,joins:J,orderBy:W,groupBy:z,limit:O,offset:U,distinct:R,setOperators:P}){let k=X??z2($);for(let o of k)if(A(o.field,T)&&h2(o.field.table)!==(A(G,f)?G._.alias:A(G,Y1)?G[h].name:A(G,K)?void 0:h2(G))&&!((e)=>J?.some(({alias:k2})=>k2===(e[F.Symbol.IsAlias]?h2(e):e[F.Symbol.BaseName])))(o.field.table)){let e=h2(o.field.table);throw Error(`Your "${o.path.join("->")}" field references a column "${e}"."${o.field.name}", but the table "${e}" is not part of the query! Did you forget to join it?`)}let x=!J||J.length===0,M=this.buildWithCTE(_),j=R?D` distinct`:void 0,S=this.buildSelection(k,{isSingleTable:x}),p=this.buildFromTable(G),B=this.buildJoins(J),s=Z?D` where ${Z}`:void 0,c=Y?D` having ${Y}`:void 0,N=[];if(z){for(let[o,e]of z.entries())if(N.push(e),o<z.length-1)N.push(D`, `)}let v=N.length>0?D` group by ${D.join(N)}`:void 0,V=this.buildOrderBy(W),J2=this.buildLimit(O),U2=U?D` offset ${U}`:void 0,X2=D`${M}select${j} ${S} from ${p}${B}${s}${v}${c}${V}${J2}${U2}`;if(P.length>0)return this.buildSetOperations(X2,P);return X2}buildSetOperations(_,$){let[X,...Z]=$;if(!X)throw Error("Cannot pass undefined values to any set operator");if(Z.length===0)return this.buildSetOperationQuery({leftSelect:_,setOperator:X});return this.buildSetOperations(this.buildSetOperationQuery({leftSelect:_,setOperator:X}),Z)}buildSetOperationQuery({leftSelect:_,setOperator:{type:$,isAll:X,rightSelect:Z,limit:Y,orderBy:G,offset:J}}){let W=D`${_.getSQL()} `,z=D`${Z.getSQL()}`,O;if(G&&G.length>0){let k=[];for(let x of G)if(A(x,y))k.push(D.identifier(x.name));else if(A(x,K)){for(let M=0;M<x.queryChunks.length;M++){let j=x.queryChunks[M];if(A(j,y))x.queryChunks[M]=D.identifier(this.casing.getColumnCasing(j))}k.push(D`${x}`)}else k.push(D`${x}`);O=D` order by ${D.join(k,D`, `)}`}let U=typeof Y==="object"||typeof Y==="number"&&Y>=0?D` limit ${Y}`:void 0,R=D.raw(`${$} ${X?"all ":""}`),P=J?D` offset ${J}`:void 0;return D`${W}${R}${z}${O}${U}${P}`}buildInsertQuery({table:_,values:$,onConflict:X,returning:Z,withList:Y,select:G}){let J=[],W=_[F.Symbol.Columns],z=Object.entries(W).filter(([x,M])=>!M.shouldDisableInsert()),O=z.map(([,x])=>D.identifier(this.casing.getColumnCasing(x)));if(G){let x=$;if(A(x,K))J.push(x);else J.push(x.getSQL())}else{let x=$;J.push(D.raw("values "));for(let[M,j]of x.entries()){let S=[];for(let[p,B]of z){let s=j[p];if(s===void 0||A(s,Y2)&&s.value===void 0){let c;if(B.default!==null&&B.default!==void 0)c=A(B.default,K)?B.default:D.param(B.default,B);else if(B.defaultFn!==void 0){let N=B.defaultFn();c=A(N,K)?N:D.param(N,B)}else if(!B.default&&B.onUpdateFn!==void 0){let N=B.onUpdateFn();c=A(N,K)?N:D.param(N,B)}else c=D`null`;S.push(c)}else S.push(s)}if(J.push(S),M<x.length-1)J.push(D`, `)}}let U=this.buildWithCTE(Y),R=D.join(J),P=Z?D` returning ${this.buildSelection(Z,{isSingleTable:!0})}`:void 0,k=X?.length?D.join(X):void 0;return D`${U}insert into ${_} ${O} ${R}${k}${P}`}sqlToQuery(_,$){return _.toQuery({casing:this.casing,escapeName:this.escapeName,escapeParam:this.escapeParam,escapeString:this.escapeString,invokeSource:$})}buildRelationalQuery({fullSchema:_,schema:$,tableNamesMap:X,table:Z,tableConfig:Y,queryConfig:G,tableAlias:J,nestedQueryRelation:W,joinOn:z}){let O=[],U,R,P=[],k,x=[];if(G===!0)O=Object.entries(Y.columns).map(([S,p])=>({dbKey:p.name,tsKey:S,field:x2(p,J),relationTableTsKey:void 0,isJson:!1,selection:[]}));else{let j=Object.fromEntries(Object.entries(Y.columns).map(([N,v])=>[N,x2(v,J)]));if(G.where){let N=typeof G.where==="function"?G.where(j,b6()):G.where;k=N&&S1(N,J)}let S=[],p=[];if(G.columns){let N=!1;for(let[v,V]of Object.entries(G.columns)){if(V===void 0)continue;if(v in Y.columns){if(!N&&V===!0)N=!0;p.push(v)}}if(p.length>0)p=N?p.filter((v)=>G.columns?.[v]===!0):Object.keys(Y.columns).filter((v)=>!p.includes(v))}else p=Object.keys(Y.columns);for(let N of p){let v=Y.columns[N];S.push({tsKey:N,value:v})}let B=[];if(G.with)B=Object.entries(G.with).filter((N)=>!!N[1]).map(([N,v])=>({tsKey:N,queryConfig:v,relation:Y.relations[N]}));let s;if(G.extras){s=typeof G.extras==="function"?G.extras(j,{sql:D}):G.extras;for(let[N,v]of Object.entries(s))S.push({tsKey:N,value:J_(v,J)})}for(let{tsKey:N,value:v}of S)O.push({dbKey:A(v,K.Aliased)?v.fieldAlias:Y.columns[N].name,tsKey:N,field:A(v,T)?x2(v,J):v,relationTableTsKey:void 0,isJson:!1,selection:[]});let c=typeof G.orderBy==="function"?G.orderBy(j,d6()):G.orderBy??[];if(!Array.isArray(c))c=[c];P=c.map((N)=>{if(A(N,T))return x2(N,J);return S1(N,J)}),U=G.limit,R=G.offset;for(let{tsKey:N,queryConfig:v,relation:V}of B){let J2=u6($,X,V),U2=t2(V.referencedTable),X2=X[U2],o=`${J}_${N}`,e=b1(...J2.fields.map((b4,d4)=>o2(x2(J2.references[d4],o),x2(b4,J)))),k2=this.buildRelationalQuery({fullSchema:_,schema:$,tableNamesMap:X,table:_[X2],tableConfig:$[X2],queryConfig:A(V,y2)?v===!0?{limit:1}:{...v,limit:1}:v,tableAlias:o,joinOn:e,nestedQueryRelation:V}),g4=D`(${k2.sql})`.as(N);O.push({dbKey:N,tsKey:N,field:g4,relationTableTsKey:X2,isJson:!0,selection:k2.selection})}}if(O.length===0)throw new W1({message:`No fields selected for table "${Y.tsName}" ("${J}"). You need to have at least one item in "columns", "with" or "extras". If you need to select all columns, omit the "columns" key or set it to undefined.`});let M;if(k=b1(z,k),W){let j=D`json_array(${D.join(O.map(({field:B})=>A(B,y)?D.identifier(this.casing.getColumnCasing(B)):A(B,K.Aliased)?B.sql:B),D`, `)})`;if(A(W,d1))j=D`coalesce(json_group_array(${j}), json_array())`;let S=[{dbKey:"data",tsKey:"data",field:j.as("data"),isJson:!0,relationTableTsKey:Y.tsName,selection:O}];if(U!==void 0||R!==void 0||P.length>0)M=this.buildSelectQuery({table:R0(Z,J),fields:{},fieldsFlat:[{path:[],field:D.raw("*")}],where:k,limit:U,offset:R,orderBy:P,setOperators:[]}),k=void 0,U=void 0,R=void 0,P=void 0;else M=R0(Z,J);M=this.buildSelectQuery({table:A(M,t)?M:new f(M,{},J),fields:{},fieldsFlat:S.map(({field:B})=>({path:[],field:A(B,T)?x2(B,J):B})),joins:x,where:k,limit:U,offset:R,orderBy:P,setOperators:[]})}else M=this.buildSelectQuery({table:R0(Z,J),fields:{},fieldsFlat:O.map(({field:j})=>({path:[],field:A(j,T)?x2(j,J):j})),joins:x,where:k,limit:U,offset:R,orderBy:P,setOperators:[]});return{tableTsKey:Y.tsName,sql:M,selection:O}}}class g_ extends B1{static[H]="SQLiteSyncDialect";migrate(_,$,X){let Z=X===void 0?"__drizzle_migrations":typeof X==="string"?"__drizzle_migrations":X.migrationsTable??"__drizzle_migrations",Y=D`
			CREATE TABLE IF NOT EXISTS ${D.identifier(Z)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;$.run(Y);let J=$.values(D`SELECT id, hash, created_at FROM ${D.identifier(Z)} ORDER BY created_at DESC LIMIT 1`)[0]??void 0;$.run(D`BEGIN`);try{for(let W of _)if(!J||Number(J[2])<W.folderMillis){for(let z of W.sql)$.run(D.raw(z));$.run(D`INSERT INTO ${D.identifier(Z)} ("hash", "created_at") VALUES(${W.hash}, ${W.folderMillis})`)}$.run(D`COMMIT`)}catch(W){throw $.run(D`ROLLBACK`),W}}}class b_ extends B1{static[H]="SQLiteAsyncDialect";async migrate(_,$,X){let Z=X===void 0?"__drizzle_migrations":typeof X==="string"?"__drizzle_migrations":X.migrationsTable??"__drizzle_migrations",Y=D`
			CREATE TABLE IF NOT EXISTS ${D.identifier(Z)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;await $.run(Y);let J=(await $.values(D`SELECT id, hash, created_at FROM ${D.identifier(Z)} ORDER BY created_at DESC LIMIT 1`))[0]??void 0;await $.transaction(async(W)=>{for(let z of _)if(!J||Number(J[2])<z.folderMillis){for(let O of z.sql)await W.run(D.raw(O));await W.run(D`INSERT INTO ${D.identifier(Z)} ("hash", "created_at") VALUES(${z.hash}, ${z.folderMillis})`)}})}}class d_{static[H]="TypedQueryBuilder";getSelectedFields(){return this._.selectedFields}}class I2{static[H]="SQLiteSelectBuilder";fields;session;dialect;withList;distinct;constructor(_){this.fields=_.fields,this.session=_.session,this.dialect=_.dialect,this.withList=_.withList,this.distinct=_.distinct}from(_){let $=!!this.fields,X;if(this.fields)X=this.fields;else if(A(_,f))X=Object.fromEntries(Object.keys(_._.selectedFields).map((Z)=>[Z,_[Z]]));else if(A(_,Y1))X=_[h].selectedFields;else if(A(_,K))X={};else X=U6(_);return new m_({table:_,fields:X,isPartialSelect:$,session:this.session,dialect:this.dialect,withList:this.withList,distinct:this.distinct})}}class P4 extends d_{static[H]="SQLiteSelectQueryBuilder";_;config;joinsNotNullableMap;tableName;isPartialSelect;session;dialect;cacheConfig=void 0;usedTables=new Set;constructor({table:_,fields:$,isPartialSelect:X,session:Z,dialect:Y,withList:G,distinct:J}){super();this.config={withList:G,table:_,fields:{...$},distinct:J,setOperators:[]},this.isPartialSelect=X,this.session=Z,this.dialect=Y,this._={selectedFields:$,config:this.config},this.tableName=g1(_),this.joinsNotNullableMap=typeof this.tableName==="string"?{[this.tableName]:!0}:{};for(let W of R2(_))this.usedTables.add(W)}getUsedTables(){return[...this.usedTables]}createJoin(_){return($,X)=>{let Z=this.tableName,Y=g1($);for(let G of R2($))this.usedTables.add(G);if(typeof Y==="string"&&this.config.joins?.some((G)=>G.alias===Y))throw Error(`Alias "${Y}" is already used in this query`);if(!this.isPartialSelect){if(Object.keys(this.joinsNotNullableMap).length===1&&typeof Z==="string")this.config.fields={[Z]:this.config.fields};if(typeof Y==="string"&&!A($,K)){let G=A($,f)?$._.selectedFields:A($,W2)?$[h].selectedFields:$[F.Symbol.Columns];this.config.fields[Y]=G}}if(typeof X==="function")X=X(new Proxy(this.config.fields,new d({sqlAliasedBehavior:"sql",sqlBehavior:"sql"})));if(!this.config.joins)this.config.joins=[];if(this.config.joins.push({on:X,table:$,joinType:_,alias:Y}),typeof Y==="string")switch(_){case"left":{this.joinsNotNullableMap[Y]=!1;break}case"right":{this.joinsNotNullableMap=Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([G])=>[G,!1])),this.joinsNotNullableMap[Y]=!0;break}case"cross":case"inner":{this.joinsNotNullableMap[Y]=!0;break}case"full":{this.joinsNotNullableMap=Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([G])=>[G,!1])),this.joinsNotNullableMap[Y]=!1;break}}return this}}leftJoin=this.createJoin("left");rightJoin=this.createJoin("right");innerJoin=this.createJoin("inner");fullJoin=this.createJoin("full");crossJoin=this.createJoin("cross");createSetOperator(_,$){return(X)=>{let Z=typeof X==="function"?X(mY()):X;if(!p1(this.getSelectedFields(),Z.getSelectedFields()))throw Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");return this.config.setOperators.push({type:_,isAll:$,rightSelect:Z}),this}}union=this.createSetOperator("union",!1);unionAll=this.createSetOperator("union",!0);intersect=this.createSetOperator("intersect",!1);except=this.createSetOperator("except",!1);addSetOperators(_){return this.config.setOperators.push(..._),this}where(_){if(typeof _==="function")_=_(new Proxy(this.config.fields,new d({sqlAliasedBehavior:"sql",sqlBehavior:"sql"})));return this.config.where=_,this}having(_){if(typeof _==="function")_=_(new Proxy(this.config.fields,new d({sqlAliasedBehavior:"sql",sqlBehavior:"sql"})));return this.config.having=_,this}groupBy(..._){if(typeof _[0]==="function"){let $=_[0](new Proxy(this.config.fields,new d({sqlAliasedBehavior:"alias",sqlBehavior:"sql"})));this.config.groupBy=Array.isArray($)?$:[$]}else this.config.groupBy=_;return this}orderBy(..._){if(typeof _[0]==="function"){let $=_[0](new Proxy(this.config.fields,new d({sqlAliasedBehavior:"alias",sqlBehavior:"sql"}))),X=Array.isArray($)?$:[$];if(this.config.setOperators.length>0)this.config.setOperators.at(-1).orderBy=X;else this.config.orderBy=X}else{let $=_;if(this.config.setOperators.length>0)this.config.setOperators.at(-1).orderBy=$;else this.config.orderBy=$}return this}limit(_){if(this.config.setOperators.length>0)this.config.setOperators.at(-1).limit=_;else this.config.limit=_;return this}offset(_){if(this.config.setOperators.length>0)this.config.setOperators.at(-1).offset=_;else this.config.offset=_;return this}getSQL(){return this.dialect.buildSelectQuery(this.config)}toSQL(){let{typings:_,...$}=this.dialect.sqlToQuery(this.getSQL());return $}as(_){let $=[];if($.push(...R2(this.config.table)),this.config.joins)for(let X of this.config.joins)$.push(...R2(X.table));return new Proxy(new f(this.getSQL(),this.config.fields,_,!1,[...new Set($)]),new d({alias:_,sqlAliasedBehavior:"alias",sqlBehavior:"error"}))}getSelectedFields(){return new Proxy(this.config.fields,new d({alias:this.tableName,sqlAliasedBehavior:"alias",sqlBehavior:"error"}))}$dynamic(){return this}}class m_ extends P4{static[H]="SQLiteSelect";_prepare(_=!0){if(!this.session)throw Error("Cannot execute a query on a query builder. Please use a database instance instead.");let $=z2(this.config.fields),X=this.session[_?"prepareOneTimeQuery":"prepareQuery"](this.dialect.sqlToQuery(this.getSQL()),$,"all",!0,void 0,{type:"select",tables:[...this.usedTables]},this.cacheConfig);return X.joinsNotNullableMap=this.joinsNotNullableMap,X}$withCache(_){return this.cacheConfig=_===void 0?{config:{},enable:!0,autoInvalidate:!0}:_===!1?{enable:!1}:{enable:!0,autoInvalidate:!0,..._},this}prepare(){return this._prepare(!1)}run=(_)=>{return this._prepare().run(_)};all=(_)=>{return this._prepare().all(_)};get=(_)=>{return this._prepare().get(_)};values=(_)=>{return this._prepare().values(_)};async execute(){return this.all()}}A6(m_,[a]);function c0(_,$){return(X,Z,...Y)=>{let G=[Z,...Y].map((J)=>({type:_,isAll:$,rightSelect:J}));for(let J of G)if(!p1(X.getSelectedFields(),J.rightSelect.getSelectedFields()))throw Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");return X.addSetOperators(G)}}var mY=()=>({union:uY,unionAll:cY,intersect:nY,except:tY}),uY=c0("union",!1),cY=c0("union",!0),nY=c0("intersect",!1),tY=c0("except",!1);class z0{static[H]="SQLiteQueryBuilder";dialect;dialectConfig;constructor(_){this.dialect=A(_,B1)?_:void 0,this.dialectConfig=A(_,B1)?void 0:_}$with=(_,$)=>{let X=this;return{as:(Y)=>{if(typeof Y==="function")Y=Y(X);return new Proxy(new f1(Y.getSQL(),$??("getSelectedFields"in Y?Y.getSelectedFields()??{}:{}),_,!0),new d({alias:_,sqlAliasedBehavior:"alias",sqlBehavior:"error"}))}}};with(..._){let $=this;function X(Y){return new I2({fields:Y??void 0,session:void 0,dialect:$.getDialect(),withList:_})}function Z(Y){return new I2({fields:Y??void 0,session:void 0,dialect:$.getDialect(),withList:_,distinct:!0})}return{select:X,selectDistinct:Z}}select(_){return new I2({fields:_??void 0,session:void 0,dialect:this.getDialect()})}selectDistinct(_){return new I2({fields:_??void 0,session:void 0,dialect:this.getDialect(),distinct:!0})}getDialect(){if(!this.dialect)this.dialect=new g_(this.dialectConfig);return this.dialect}}class n0{constructor(_,$,X,Z){this.table=_,this.session=$,this.dialect=X,this.withList=Z}static[H]="SQLiteInsertBuilder";values(_){if(_=Array.isArray(_)?_:[_],_.length===0)throw Error("values() must be called with at least one value");let $=_.map((X)=>{let Z={},Y=this.table[F.Symbol.Columns];for(let G of Object.keys(X)){let J=X[G];Z[G]=A(J,K)?J:new Y2(J,Y[G])}return Z});return new u_(this.table,$,this.session,this.dialect,this.withList)}select(_){let $=typeof _==="function"?_(new z0):_;if(!A($,K)&&!p1(this.table[V0],$._.selectedFields))throw Error("Insert select error: selected fields are not the same or are in a different order compared to the table definition");return new u_(this.table,$,this.session,this.dialect,this.withList,!0)}}class u_ extends a{constructor(_,$,X,Z,Y,G){super();this.session=X,this.dialect=Z,this.config={table:_,values:$,withList:Y,select:G}}static[H]="SQLiteInsert";config;returning(_=this.config.table[t.Symbol.Columns]){return this.config.returning=z2(_),this}onConflictDoNothing(_={}){if(!this.config.onConflict)this.config.onConflict=[];if(_.target===void 0)this.config.onConflict.push(D` on conflict do nothing`);else{let $=Array.isArray(_.target)?D`${_.target}`:D`${[_.target]}`,X=_.where?D` where ${_.where}`:D``;this.config.onConflict.push(D` on conflict ${$} do nothing${X}`)}return this}onConflictDoUpdate(_){if(_.where&&(_.targetWhere||_.setWhere))throw Error('You cannot use both "where" and "targetWhere"/"setWhere" at the same time - "where" is deprecated, use "targetWhere" or "setWhere" instead.');if(!this.config.onConflict)this.config.onConflict=[];let $=_.where?D` where ${_.where}`:void 0,X=_.targetWhere?D` where ${_.targetWhere}`:void 0,Z=_.setWhere?D` where ${_.setWhere}`:void 0,Y=Array.isArray(_.target)?D`${_.target}`:D`${[_.target]}`,G=this.dialect.buildUpdateSet(this.config.table,I0(this.config.table,_.set));return this.config.onConflict.push(D` on conflict ${Y}${X} do update set ${G}${$}${Z}`),this}getSQL(){return this.dialect.buildInsertQuery(this.config)}toSQL(){let{typings:_,...$}=this.dialect.sqlToQuery(this.getSQL());return $}_prepare(_=!0){return this.session[_?"prepareOneTimeQuery":"prepareQuery"](this.dialect.sqlToQuery(this.getSQL()),this.config.returning,this.config.returning?"all":"run",!0,void 0,{type:"insert",tables:R2(this.config.table)})}prepare(){return this._prepare(!1)}run=(_)=>{return this._prepare().run(_)};all=(_)=>{return this._prepare().all(_)};get=(_)=>{return this._prepare().get(_)};values=(_)=>{return this._prepare().values(_)};async execute(){return this.config.returning?this.all():this.run()}$dynamic(){return this}}class t0{constructor(_,$,X,Z){this.table=_,this.session=$,this.dialect=X,this.withList=Z}static[H]="SQLiteUpdateBuilder";set(_){return new k4(this.table,I0(this.table,_),this.session,this.dialect,this.withList)}}class k4 extends a{constructor(_,$,X,Z,Y){super();this.session=X,this.dialect=Z,this.config={set:$,table:_,withList:Y,joins:[]}}static[H]="SQLiteUpdate";config;from(_){return this.config.from=_,this}createJoin(_){return($,X)=>{let Z=g1($);if(typeof Z==="string"&&this.config.joins.some((Y)=>Y.alias===Z))throw Error(`Alias "${Z}" is already used in this query`);if(typeof X==="function"){let Y=this.config.from?A($,t)?$[F.Symbol.Columns]:A($,f)?$._.selectedFields:A($,Y1)?$[h].selectedFields:void 0:void 0;X=X(new Proxy(this.config.table[F.Symbol.Columns],new d({sqlAliasedBehavior:"sql",sqlBehavior:"sql"})),Y&&new Proxy(Y,new d({sqlAliasedBehavior:"sql",sqlBehavior:"sql"})))}return this.config.joins.push({on:X,table:$,joinType:_,alias:Z}),this}}leftJoin=this.createJoin("left");rightJoin=this.createJoin("right");innerJoin=this.createJoin("inner");fullJoin=this.createJoin("full");where(_){return this.config.where=_,this}orderBy(..._){if(typeof _[0]==="function"){let $=_[0](new Proxy(this.config.table[F.Symbol.Columns],new d({sqlAliasedBehavior:"alias",sqlBehavior:"sql"}))),X=Array.isArray($)?$:[$];this.config.orderBy=X}else{let $=_;this.config.orderBy=$}return this}limit(_){return this.config.limit=_,this}returning(_=this.config.table[t.Symbol.Columns]){return this.config.returning=z2(_),this}getSQL(){return this.dialect.buildUpdateQuery(this.config)}toSQL(){let{typings:_,...$}=this.dialect.sqlToQuery(this.getSQL());return $}_prepare(_=!0){return this.session[_?"prepareOneTimeQuery":"prepareQuery"](this.dialect.sqlToQuery(this.getSQL()),this.config.returning,this.config.returning?"all":"run",!0,void 0,{type:"insert",tables:R2(this.config.table)})}prepare(){return this._prepare(!1)}run=(_)=>{return this._prepare().run(_)};all=(_)=>{return this._prepare().all(_)};get=(_)=>{return this._prepare().get(_)};values=(_)=>{return this._prepare().values(_)};async execute(){return this.config.returning?this.all():this.run()}$dynamic(){return this}}class D0 extends K{constructor(_){super(D0.buildEmbeddedCount(_.source,_.filters).queryChunks);this.params=_,this.session=_.session,this.sql=D0.buildCount(_.source,_.filters)}sql;static[H]="SQLiteCountBuilderAsync";[Symbol.toStringTag]="SQLiteCountBuilderAsync";session;static buildEmbeddedCount(_,$){return D`(select count(*) from ${_}${D.raw(" where ").if($)}${$})`}static buildCount(_,$){return D`select count(*) from ${_}${D.raw(" where ").if($)}${$}`}then(_,$){return Promise.resolve(this.session.count(this.sql)).then(_,$)}catch(_){return this.then(void 0,_)}finally(_){return this.then(($)=>{return _?.(),$},($)=>{throw _?.(),$})}}class n_{constructor(_,$,X,Z,Y,G,J,W){this.mode=_,this.fullSchema=$,this.schema=X,this.tableNamesMap=Z,this.table=Y,this.tableConfig=G,this.dialect=J,this.session=W}static[H]="SQLiteAsyncRelationalQueryBuilder";findMany(_){return this.mode==="sync"?new c_(this.fullSchema,this.schema,this.tableNamesMap,this.table,this.tableConfig,this.dialect,this.session,_?_:{},"many"):new o0(this.fullSchema,this.schema,this.tableNamesMap,this.table,this.tableConfig,this.dialect,this.session,_?_:{},"many")}findFirst(_){return this.mode==="sync"?new c_(this.fullSchema,this.schema,this.tableNamesMap,this.table,this.tableConfig,this.dialect,this.session,_?{..._,limit:1}:{limit:1},"first"):new o0(this.fullSchema,this.schema,this.tableNamesMap,this.table,this.tableConfig,this.dialect,this.session,_?{..._,limit:1}:{limit:1},"first")}}class o0 extends a{constructor(_,$,X,Z,Y,G,J,W,z){super();this.fullSchema=_,this.schema=$,this.tableNamesMap=X,this.table=Z,this.tableConfig=Y,this.dialect=G,this.session=J,this.config=W,this.mode=z}static[H]="SQLiteAsyncRelationalQuery";mode;getSQL(){return this.dialect.buildRelationalQuery({fullSchema:this.fullSchema,schema:this.schema,tableNamesMap:this.tableNamesMap,table:this.table,tableConfig:this.tableConfig,queryConfig:this.config,tableAlias:this.tableConfig.tsName}).sql}_prepare(_=!1){let{query:$,builtQuery:X}=this._toSQL();return this.session[_?"prepareOneTimeQuery":"prepareQuery"](X,void 0,this.mode==="first"?"get":"all",!0,(Z,Y)=>{let G=Z.map((J)=>x0(this.schema,this.tableConfig,J,$.selection,Y));if(this.mode==="first")return G[0];return G})}prepare(){return this._prepare(!1)}_toSQL(){let _=this.dialect.buildRelationalQuery({fullSchema:this.fullSchema,schema:this.schema,tableNamesMap:this.tableNamesMap,table:this.table,tableConfig:this.tableConfig,queryConfig:this.config,tableAlias:this.tableConfig.tsName}),$=this.dialect.sqlToQuery(_.sql);return{query:_,builtQuery:$}}toSQL(){return this._toSQL().builtQuery}executeRaw(){if(this.mode==="first")return this._prepare(!1).get();return this._prepare(!1).all()}async execute(){return this.executeRaw()}}class c_ extends o0{static[H]="SQLiteSyncRelationalQuery";sync(){return this.executeRaw()}}class T1 extends a{constructor(_,$,X,Z,Y){super();this.execute=_,this.getSQL=$,this.dialect=Z,this.mapBatchResult=Y,this.config={action:X}}static[H]="SQLiteRaw";config;getQuery(){return{...this.dialect.sqlToQuery(this.getSQL()),method:this.config.action}}mapResult(_,$){return $?this.mapBatchResult(_):_}_prepare(){return this}isResponseInArrayMode(){return!1}}class O0{constructor(_,$,X,Z){this.resultKind=_,this.dialect=$,this.session=X,this._=Z?{schema:Z.schema,fullSchema:Z.fullSchema,tableNamesMap:Z.tableNamesMap}:{schema:void 0,fullSchema:{},tableNamesMap:{}},this.query={};let Y=this.query;if(this._.schema)for(let[G,J]of Object.entries(this._.schema))Y[G]=new n_(_,Z.fullSchema,this._.schema,this._.tableNamesMap,Z.fullSchema[G],J,$,X);this.$cache={invalidate:async(G)=>{}}}static[H]="BaseSQLiteDatabase";query;$with=(_,$)=>{let X=this;return{as:(Y)=>{if(typeof Y==="function")Y=Y(new z0(X.dialect));return new Proxy(new f1(Y.getSQL(),$??("getSelectedFields"in Y?Y.getSelectedFields()??{}:{}),_,!0),new d({alias:_,sqlAliasedBehavior:"alias",sqlBehavior:"error"}))}}};$count(_,$){return new D0({source:_,filters:$,session:this.session})}with(..._){let $=this;function X(W){return new I2({fields:W??void 0,session:$.session,dialect:$.dialect,withList:_})}function Z(W){return new I2({fields:W??void 0,session:$.session,dialect:$.dialect,withList:_,distinct:!0})}function Y(W){return new t0(W,$.session,$.dialect,_)}function G(W){return new n0(W,$.session,$.dialect,_)}function J(W){return new u0(W,$.session,$.dialect,_)}return{select:X,selectDistinct:Z,update:Y,insert:G,delete:J}}select(_){return new I2({fields:_??void 0,session:this.session,dialect:this.dialect})}selectDistinct(_){return new I2({fields:_??void 0,session:this.session,dialect:this.dialect,distinct:!0})}update(_){return new t0(_,this.session,this.dialect)}$cache;insert(_){return new n0(_,this.session,this.dialect)}delete(_){return new u0(_,this.session,this.dialect)}run(_){let $=typeof _==="string"?D.raw(_):_.getSQL();if(this.resultKind==="async")return new T1(async()=>this.session.run($),()=>$,"run",this.dialect,this.session.extractRawRunValueFromBatchResult.bind(this.session));return this.session.run($)}all(_){let $=typeof _==="string"?D.raw(_):_.getSQL();if(this.resultKind==="async")return new T1(async()=>this.session.all($),()=>$,"all",this.dialect,this.session.extractRawAllValueFromBatchResult.bind(this.session));return this.session.all($)}get(_){let $=typeof _==="string"?D.raw(_):_.getSQL();if(this.resultKind==="async")return new T1(async()=>this.session.get($),()=>$,"get",this.dialect,this.session.extractRawGetValueFromBatchResult.bind(this.session));return this.session.get($)}values(_){let $=typeof _==="string"?D.raw(_):_.getSQL();if(this.resultKind==="async")return new T1(async()=>this.session.values($),()=>$,"values",this.dialect,this.session.extractRawValuesValueFromBatchResult.bind(this.session));return this.session.values($)}transaction(_,$){return this.session.transaction(_,$)}}class j4{static[H]="Cache"}class H0 extends j4{strategy(){return"all"}static[H]="NoopCache";async get(_){return}async put(_,$,X,Z){}async onMutate(_){}}async function t_(_,$){let X=`${_}-${JSON.stringify($)}`,Y=new TextEncoder().encode(X),G=await crypto.subtle.digest("SHA-256",Y);return[...new Uint8Array(G)].map((z)=>z.toString(16).padStart(2,"0")).join("")}class B4 extends a{constructor(_){super();this.resultCb=_}static[H]="ExecuteResultSync";async execute(){return this.resultCb()}sync(){return this.resultCb()}}class o_{constructor(_,$,X,Z,Y,G){if(this.mode=_,this.executeMethod=$,this.query=X,this.cache=Z,this.queryMetadata=Y,this.cacheConfig=G,Z&&Z.strategy()==="all"&&G===void 0)this.cacheConfig={enable:!0,autoInvalidate:!0};if(!this.cacheConfig?.enable)this.cacheConfig=void 0}static[H]="PreparedQuery";joinsNotNullableMap;async queryWithCache(_,$,X){if(this.cache===void 0||A(this.cache,H0)||this.queryMetadata===void 0)try{return await X()}catch(Z){throw new T2(_,$,Z)}if(this.cacheConfig&&!this.cacheConfig.enable)try{return await X()}catch(Z){throw new T2(_,$,Z)}if((this.queryMetadata.type==="insert"||this.queryMetadata.type==="update"||this.queryMetadata.type==="delete")&&this.queryMetadata.tables.length>0)try{let[Z]=await Promise.all([X(),this.cache.onMutate({tables:this.queryMetadata.tables})]);return Z}catch(Z){throw new T2(_,$,Z)}if(!this.cacheConfig)try{return await X()}catch(Z){throw new T2(_,$,Z)}if(this.queryMetadata.type==="select"){let Z=await this.cache.get(this.cacheConfig.tag??await t_(_,$),this.queryMetadata.tables,this.cacheConfig.tag!==void 0,this.cacheConfig.autoInvalidate);if(Z===void 0){let Y;try{Y=await X()}catch(G){throw new T2(_,$,G)}return await this.cache.put(this.cacheConfig.tag??await t_(_,$),Y,this.cacheConfig.autoInvalidate?this.queryMetadata.tables:[],this.cacheConfig.tag!==void 0,this.cacheConfig.config),Y}return Z}try{return await X()}catch(Z){throw new T2(_,$,Z)}}getQuery(){return this.query}mapRunResult(_,$){return _}mapAllResult(_,$){throw Error("Not implemented")}mapGetResult(_,$){throw Error("Not implemented")}execute(_){if(this.mode==="async")return this[this.executeMethod](_);return new B4(()=>this[this.executeMethod](_))}mapResult(_,$){switch(this.executeMethod){case"run":return this.mapRunResult(_,$);case"all":return this.mapAllResult(_,$);case"get":return this.mapGetResult(_,$)}}}class i_{constructor(_){this.dialect=_}static[H]="SQLiteSession";prepareOneTimeQuery(_,$,X,Z,Y,G,J){return this.prepareQuery(_,$,X,Z,Y,G,J)}run(_){let $=this.dialect.sqlToQuery(_);try{return this.prepareOneTimeQuery($,void 0,"run",!1).run()}catch(X){throw new W1({cause:X,message:`Failed to run the query '${$.sql}'`})}}extractRawRunValueFromBatchResult(_){return _}all(_){return this.prepareOneTimeQuery(this.dialect.sqlToQuery(_),void 0,"run",!1).all()}extractRawAllValueFromBatchResult(_){throw Error("Not implemented")}get(_){return this.prepareOneTimeQuery(this.dialect.sqlToQuery(_),void 0,"run",!1).get()}extractRawGetValueFromBatchResult(_){throw Error("Not implemented")}values(_){return this.prepareOneTimeQuery(this.dialect.sqlToQuery(_),void 0,"run",!1).values()}async count(_){return(await this.values(_))[0][0]}extractRawValuesValueFromBatchResult(_){throw Error("Not implemented")}}class r_ extends O0{constructor(_,$,X,Z,Y=0){super(_,$,X,Z);this.schema=Z,this.nestedIndex=Y}static[H]="SQLiteTransaction";rollback(){throw new W_}}class r0 extends i_{constructor(_,$,X,Z,Y){super($);this.client=_,this.schema=X,this.options=Z,this.tx=Y,this.logger=Z.logger??new D_,this.cache=Z.cache??new H0}static[H]="LibSQLSession";logger;cache;prepareQuery(_,$,X,Z,Y,G,J){return new Q4(this.client,_,this.logger,this.cache,G,J,$,this.tx,X,Z,Y)}async batch(_){let $=[],X=[];for(let Y of _){let G=Y._prepare(),J=G.getQuery();$.push(G),X.push({sql:J.sql,args:J.params})}return(await this.client.batch(X)).map((Y,G)=>$[G].mapResult(Y,!0))}async migrate(_){let $=[],X=[];for(let Y of _){let G=Y._prepare(),J=G.getQuery();$.push(G),X.push({sql:J.sql,args:J.params})}return(await this.client.migrate(X)).map((Y,G)=>$[G].mapResult(Y,!0))}async transaction(_,$){let X=await this.client.transaction(),Z=new r0(this.client,this.dialect,this.schema,this.options,X),Y=new s_("async",this.dialect,Z,this.schema);try{let G=await _(Y);return await X.commit(),G}catch(G){throw await X.rollback(),G}}extractRawAllValueFromBatchResult(_){return _.rows}extractRawGetValueFromBatchResult(_){return _.rows[0]}extractRawValuesValueFromBatchResult(_){return _.rows}}class s_ extends r_{static[H]="LibSQLTransaction";async transaction(_){let $=`sp${this.nestedIndex}`,X=new s_("async",this.dialect,this.session,this.schema,this.nestedIndex+1);await this.session.run(D.raw(`savepoint ${$}`));try{let Z=await _(X);return await this.session.run(D.raw(`release savepoint ${$}`)),Z}catch(Z){throw await this.session.run(D.raw(`rollback to savepoint ${$}`)),Z}}}class Q4 extends o_{constructor(_,$,X,Z,Y,G,J,W,z,O,U){super("async",z,$,Z,Y,G);this.client=_,this.logger=X,this.fields=J,this.tx=W,this._isResponseInArrayMode=O,this.customResultMapper=U,this.customResultMapper=U,this.fields=J}static[H]="LibSQLPreparedQuery";async run(_){let $=q1(this.query.params,_??{});return this.logger.logQuery(this.query.sql,$),await this.queryWithCache(this.query.sql,$,async()=>{let X={sql:this.query.sql,args:$};return this.tx?this.tx.execute(X):this.client.execute(X)})}async all(_){let{fields:$,logger:X,query:Z,tx:Y,client:G,customResultMapper:J}=this;if(!$&&!J){let z=q1(Z.params,_??{});return X.logQuery(Z.sql,z),await this.queryWithCache(Z.sql,z,async()=>{let O={sql:Z.sql,args:z};return(Y?Y.execute(O):G.execute(O)).then(({rows:U})=>this.mapAllResult(U))})}let W=await this.values(_);return this.mapAllResult(W)}mapAllResult(_,$){if($)_=_.rows;if(!this.fields&&!this.customResultMapper)return _.map((X)=>T4(X));if(this.customResultMapper)return this.customResultMapper(_,i0);return _.map((X)=>{return O_(this.fields,Array.prototype.slice.call(X).map((Z)=>i0(Z)),this.joinsNotNullableMap)})}async get(_){let{fields:$,logger:X,query:Z,tx:Y,client:G,customResultMapper:J}=this;if(!$&&!J){let z=q1(Z.params,_??{});return X.logQuery(Z.sql,z),await this.queryWithCache(Z.sql,z,async()=>{let O={sql:Z.sql,args:z};return(Y?Y.execute(O):G.execute(O)).then(({rows:U})=>this.mapGetResult(U))})}let W=await this.values(_);return this.mapGetResult(W)}mapGetResult(_,$){if($)_=_.rows;let X=_[0];if(!this.fields&&!this.customResultMapper)return T4(X);if(!X)return;if(this.customResultMapper)return this.customResultMapper(_,i0);return O_(this.fields,Array.prototype.slice.call(X).map((Z)=>i0(Z)),this.joinsNotNullableMap)}async values(_){let $=q1(this.query.params,_??{});return this.logger.logQuery(this.query.sql,$),await this.queryWithCache(this.query.sql,$,async()=>{let X={sql:this.query.sql,args:$};return(this.tx?this.tx.execute(X):this.client.execute(X)).then(({rows:Z})=>Z)})}isResponseInArrayMode(){return this._isResponseInArrayMode}}function T4(_){return Object.keys(_).reduce(($,X)=>{if(Object.prototype.propertyIsEnumerable.call(_,X))$[X]=_[X];return $},{})}function i0(_){if(typeof ArrayBuffer<"u"&&_ instanceof ArrayBuffer){if(typeof Buffer<"u"){if(!(_ instanceof Buffer))return Buffer.from(_);return _}if(typeof TextDecoder<"u")return new TextDecoder().decode(_);throw Error("TextDecoder is not available. Please provide either Buffer or TextDecoder polyfill.")}return _}class L4 extends O0{static[H]="LibSQLDatabase";async batch(_){return this.session.batch(_)}}function Q1(_,$={}){let X=new b_({casing:$.casing}),Z;if($.logger===!0)Z=new z_;else if($.logger!==!1)Z=$.logger;let Y;if($.schema){let W=m6($.schema,c6);Y={fullSchema:$.schema,schema:W.tables,tableNamesMap:W.tableNamesMap}}let G=new r0(_,X,Y,{logger:Z,cache:$.cache},void 0),J=new L4("async",X,G,Y);if(J.$client=_,J.$cache=$.cache,J.$cache)J.$cache.invalidate=$.cache?.onMutate;return J}function s0(..._){if(typeof _[0]==="string"){let $=j1({url:_[0]});return Q1($,_[1])}if(F6(_[0])){let{connection:$,client:X,...Z}=_[0];if(X)return Q1(X,Z);let Y=typeof $==="string"?j1({url:$}):j1($);return Q1(Y,Z)}return Q1(_[0],_[1])}((_)=>{function $(X){return Q1({},X)}_.mock=$})(s0||(s0={}));var a0={};t4(a0,{verification:()=>rY,user:()=>A0,threads:()=>aY,session:()=>oY,redditSyncState:()=>eY,products:()=>l0,keywords:()=>sY,blockedAuthors:()=>lY,account:()=>iY});function A2(_){return H2(_,{mode:"timestamp"})}var A0=K2("user",{id:I("id").primaryKey(),name:I("name").notNull(),email:I("email").notNull().unique(),emailVerified:H2("email_verified",{mode:"boolean"}).notNull(),image:I("image"),createdAt:A2("created_at").notNull(),updatedAt:A2("updated_at").notNull()}),oY=K2("session",{id:I("id").primaryKey(),userId:I("user_id").notNull().references(()=>A0.id),token:I("token").notNull().unique(),expiresAt:A2("expires_at").notNull(),ipAddress:I("ip_address"),userAgent:I("user_agent"),createdAt:A2("created_at").notNull(),updatedAt:A2("updated_at").notNull()}),iY=K2("account",{id:I("id").primaryKey(),userId:I("user_id").notNull().references(()=>A0.id),accountId:I("account_id").notNull(),providerId:I("provider_id").notNull(),accessToken:I("access_token"),refreshToken:I("refresh_token"),accessTokenExpiresAt:A2("access_token_expires_at"),refreshTokenExpiresAt:A2("refresh_token_expires_at"),scope:I("scope"),idToken:I("id_token"),password:I("password"),createdAt:A2("created_at").notNull(),updatedAt:A2("updated_at").notNull()}),rY=K2("verification",{id:I("id").primaryKey(),identifier:I("identifier").notNull(),value:I("value").notNull(),expiresAt:A2("expires_at").notNull(),createdAt:A2("created_at"),updatedAt:A2("updated_at")});var l0=K2("products",{id:I("id").primaryKey(),userId:I("user_id").notNull().references(()=>A0.id),url:I("url").notNull(),name:I("name").notNull(),description:I("description").notNull(),targetAudience:I("target_audience").notNull(),createdAt:H2("created_at").notNull()}),sY=K2("keywords",{id:I("id").primaryKey(),productId:I("product_id").notNull().references(()=>l0.id,{onDelete:"cascade"}),keyword:I("keyword").notNull()}),lY=K2("blocked_authors",{id:I("id").primaryKey(),productId:I("product_id").notNull().references(()=>l0.id,{onDelete:"cascade"}),username:I("username").notNull()}),aY=K2("threads",{id:I("id").primaryKey(),productId:I("product_id").notNull().references(()=>l0.id,{onDelete:"cascade"}),redditThreadId:I("reddit_thread_id").notNull(),title:I("title").notNull(),bodyPreview:I("body_preview").notNull(),subreddit:I("subreddit").notNull(),url:I("url").notNull(),createdUtc:H2("created_utc").notNull(),discoveredAt:H2("discovered_at").notNull(),status:I("status",{enum:["active","dismissed"]}).notNull().default("active"),isNew:H2("is_new",{mode:"boolean"}).notNull().default(!0),matchedKeyword:I("matched_keyword"),type:I("type",{enum:["post","comment"]}).default("post"),commentBody:I("comment_body"),parentPostId:I("parent_post_id"),parentPostTitle:I("parent_post_title"),generatedResponse:I("generated_response"),customInstructions:I("custom_instructions"),relevanceScore:H2("relevance_score")}),eY=K2("reddit_sync_state",{id:I("id").primaryKey().default("global"),lastPostId:I("last_post_id").notNull(),lastCommentId:I("last_comment_id"),updatedAt:H2("updated_at").notNull()});var v4={"User-Agent":"Mozilla/5.0 (compatible; QuillRedditAgent/1.0; +https://reddit-agent.vercel.app)",Accept:"application/json","Accept-Language":"en-US,en;q=0.9"};function L1(_){let $=0n;for(let X of _.toLowerCase()){let Z="0123456789abcdefghijklmnopqrstuvwxyz".indexOf(X);if(Z===-1)throw Error(`Invalid base36 character: ${X}`);$=$*36n+BigInt(Z)}return $}function _G(_){if(_===0n)return"0";let $="",X=_;while(X>0)$="0123456789abcdefghijklmnopqrstuvwxyz"[Number(X%36n)]+$,X=X/36n;return $}function l_(_,$=500){let X=L1(_),Z=[];for(let Y=1n;Y<=BigInt($);Y++)Z.push(_G(X+Y));return Z}async function C4(_){if(_.length===0)return[];let X=`https://api.reddit.com/api/info.json?id=${_.map((Z)=>`t3_${Z}`).join(",")}&raw_json=1`;console.log(`[Reddit] Fetching batch of ${_.length} posts...`);try{let Z=await fetch(X,{headers:v4});if(!Z.ok){let W=await Z.text().catch(()=>"");return console.error(`[Reddit] batchFetchPosts failed: ${Z.status} ${Z.statusText}`,{idsCount:_.length,responseBody:W.slice(0,500)}),[]}let J=((await Z.json())?.data?.children??[]).filter((W)=>W.kind==="t3").map((W)=>W.data);return console.log(`[Reddit] Got ${J.length} posts from batch of ${_.length}`),J}catch(Z){return console.error("[Reddit] batchFetchPosts error:",Z),[]}}async function f4(_){if(_.length===0)return[];let X=`https://api.reddit.com/api/info.json?id=${_.map((Z)=>`t1_${Z}`).join(",")}&raw_json=1`;console.log(`[Reddit] Fetching batch of ${_.length} comments...`);try{let Z=await fetch(X,{headers:v4});if(!Z.ok){let W=await Z.text().catch(()=>"");return console.error(`[Reddit] batchFetchComments failed: ${Z.status} ${Z.statusText}`,{idsCount:_.length,responseBody:W.slice(0,500)}),[]}let J=((await Z.json())?.data?.children??[]).filter((W)=>W.kind==="t1").map((W)=>W.data);return console.log(`[Reddit] Got ${J.length} comments from batch of ${_.length}`),J}catch(Z){return console.error("[Reddit] batchFetchComments error:",Z),[]}}function $G(_){let $=_.replace(/[.*+?^${}()|[\]\\]/g,"\\$&");return new RegExp(`\\b${$}s?\\b`,"i")}class h4{entries;constructor(_){this.entries=_.map(($)=>{let X=$.keyword.toLowerCase().split(/\s+/).filter(Boolean);return{...$,words:X,patterns:X.map($G)}})}match(_){let $=[],X=new Set;for(let Z of this.entries)if(Z.patterns.every((G)=>G.test(_))){let G=`${Z.productId}:${Z.keyword}`;if(!X.has(G))X.add(G),$.push({keyword:Z.keyword,productId:Z.productId})}return $}}function q4(_){return new h4(_)}function S4(_,$){let X=[];for(let Z=0;Z<_.length;Z+=$)X.push(_.slice(Z,Z+$));return X}var p4=process.env.TURSO_DATABASE_URL;if(!p4)console.error("[Cron] TURSO_DATABASE_URL environment variable is required"),process.exit(1);var XG=j1({url:p4,authToken:process.env.TURSO_AUTH_TOKEN}),f2=s0(XG,{schema:a0}),{keywords:a_,threads:U0,redditSyncState:v1,blockedAuthors:e_}=a0;async function ZG(){let _=Date.now();console.log("[Cron] Starting discover job..."),console.log(`[Cron] Time: ${new Date().toISOString()}`);try{let[$]=await f2.select().from(v1).where(o2(v1.id,"global")),X="1i5abc",Z=$?.lastPostId??"1i5abc";console.log(`[Cron] Starting from post ID: ${Z}`);let Y=await f2.select({keyword:a_.keyword,productId:a_.productId}).from(a_);if(Y.length===0){console.log("[Cron] No keywords configured, skipping");let V=Math.floor(Date.now()/1000);if(!$)await f2.insert(v1).values({id:"global",lastPostId:Z,updatedAt:V});console.log("[Cron] Done (no keywords)");return}console.log(`[Cron] Monitoring ${Y.length} keywords`);let G=Y.map((V)=>({keyword:V.keyword,productId:V.productId})),J=q4(G),W=await f2.select({username:e_.username,productId:e_.productId}).from(e_),z=new Map;for(let V of W){if(!z.has(V.productId))z.set(V.productId,new Set);z.get(V.productId).add(V.username.toLowerCase())}console.log(`[Cron] Loaded ${W.length} blocked authors across products`);let O=l_(Z,3000);console.log(`[Cron] Fetching ${O.length} post IDs...`);let U=[];for(let V=0;V<O.length;V+=100){let J2=O.slice(V,V+100),U2=await C4(J2);U.push(...U2)}if(console.log(`[Cron] Fetched ${U.length} posts from Reddit API`),U.length===0)console.warn("[Cron] WARNING: Got 0 posts from Reddit API - possible IP blocking or rate limiting");let R=Z;for(let V of U)if(L1(V.id)>L1(R))R=V.id;let P=await f2.select({redditThreadId:U0.redditThreadId,productId:U0.productId}).from(U0),k=new Set(P.map((V)=>`${V.productId}:${V.redditThreadId}`)),x=Math.floor(Date.now()/1000)-2592000,M=Math.floor(Date.now()/1000),j=[];for(let V of U){if(V.created_utc<x)continue;let J2=`${V.title} ${V.selftext}`,U2=J.match(J2),X2=V.author.toLowerCase();for(let o of U2){if(z.get(o.productId)?.has(X2))continue;let k2=`${o.productId}:${V.id}`;if(k.has(k2))continue;k.add(k2),j.push({id:y4(),productId:o.productId,redditThreadId:V.id,title:V.title,bodyPreview:V.selftext.slice(0,200),subreddit:V.subreddit,url:`https://reddit.com${V.permalink}`,createdUtc:V.created_utc,discoveredAt:M,status:"active",isNew:!0,matchedKeyword:o.keyword})}}if(j.length>0){for(let V of S4(j,50))await f2.insert(U0).values(V);console.log(`[Cron] Inserted ${j.length} new post threads`)}let S="o0v5dc2",p=$?.lastCommentId??S;console.log(`[Cron] Starting comment discovery from ID: ${p}`);let B=l_(p,3000);console.log(`[Cron] Fetching ${B.length} comment IDs...`);let s=[];for(let V=0;V<B.length;V+=100){let J2=B.slice(V,V+100),U2=await f4(J2);s.push(...U2)}if(console.log(`[Cron] Fetched ${s.length} comments from Reddit API`),s.length===0)console.warn("[Cron] WARNING: Got 0 comments from Reddit API - possible IP blocking or rate limiting");let c=p;for(let V of s)if(L1(V.id)>L1(c))c=V.id;let N=[];for(let V of s){if(V.created_utc<x)continue;let J2=J.match(V.body),U2=V.author.toLowerCase();for(let X2 of J2){if(z.get(X2.productId)?.has(U2))continue;let e=`${X2.productId}:${V.id}`;if(k.has(e))continue;k.add(e);let k2=V.link_id.replace("t3_","");N.push({id:y4(),productId:X2.productId,redditThreadId:V.id,title:V.link_title||"[Comment]",bodyPreview:V.body.slice(0,200),subreddit:V.subreddit,url:`https://reddit.com${V.permalink}`,createdUtc:V.created_utc,discoveredAt:M,status:"active",isNew:!0,matchedKeyword:X2.keyword,type:"comment",commentBody:V.body,parentPostId:k2,parentPostTitle:V.link_title||""})}}if(N.length>0){for(let V of S4(N,50))await f2.insert(U0).values(V);console.log(`[Cron] Inserted ${N.length} new comment threads`)}if(!$)await f2.insert(v1).values({id:"global",lastPostId:R,lastCommentId:c,updatedAt:M});else await f2.update(v1).set({lastPostId:R,lastCommentId:c,updatedAt:M}).where(o2(v1.id,"global"));let v=Date.now()-_;console.log(`[Cron] Completed in ${v}ms`,{postsProcessed:U.length,commentsProcessed:s.length,newPostThreadsFound:j.length,newCommentThreadsFound:N.length,lastPostId:R,lastCommentId:c})}catch($){let X=Date.now()-_;console.error(`[Cron] Fatal error after ${X}ms:`,$),process.exit(1)}}ZG().then(()=>{console.log("[Cron] Job finished successfully"),process.exit(0)}).catch((_)=>{console.error("[Cron] Unhandled error:",_),process.exit(1)});
